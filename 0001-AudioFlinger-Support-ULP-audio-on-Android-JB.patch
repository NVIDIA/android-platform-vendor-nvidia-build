From 03cef1aed675f22f066e853ea23344034c9d4a1b Mon Sep 17 00:00:00 2001
From: Dara Ramesh <dramesh@nvidia.com>
Date: Mon, 9 Jul 2012 16:50:28 +0530
Subject: [PATCH] AudioFlinger: Support ULP audio on Android JB

Integrated the following changes to enable
audio ULP playback on JB.

Define ULP audio support macro.
Add support for volume control of ULP stream.
Avoid zero padding for non PCM streams.
Fix ULP audio routing issue.

Following are the commits integrated:
http://git-master/r/#change,108840
http://git-master/r/#change,109733
http://git-master/r/#change,100529
http://git-master/r/#change,109259

Change-Id: I1cb80da58ce1836387208d6a2995f067b2c5ed14

AudioSink: Don't send silence data after EOS for non-pcm stream

Bug 968814

Change-Id: Ie2204936b007062dc1f425001075646cfa2f7516

AudioFlinger: Increase track retry count for ULP stream

For ULP playback libaudio consumes data as fast as possible. if parser
is not fast enough it is very much possible for audioflinger to get
starved. Increase audioflinger direct thread retry count for ULP streams
so that audioflinger does not remove ULP audio track from active track
list easily.
Also for ULP streams standby may take long time to complete. Release
mLock before entering standby to ensure other threads do not get
blocked.

Change-Id: I6763ff291b2623ca68126b9856256b9bc95b7b7a

AudioFlinger: Fix ULP audio pause issue

Due to changes in JB audioflinger logic for ULP streams standby was
never getting called after pause because for ULP stream silence data
is not sent to libaudio after audiotrack pauses/stops.This commit
will ensure for non-PCM streams libaudio standby is immediately called
after pause/stop.

For ULP streams audioflinger re-directs any stream setparameter call
to device setparameter call. To identify the targetted stream for
which setparam was originally called append an extra parameter named
"nv_param_io_handle" from AudioFlinger.

Change-Id: I19fa87c680689a0dc15b77a48a671807492cd127

AudioFlinger: Fix ulp volume control issue near EOS

For ulp stream corresponding audio track is removed from active
track list before standby completes and as a result after EOS is
reached at SF layer volume control stops working for ULP streams.
To fix this issue store ULP audio track handle in a seperate
variable when track starts and invalidate it only when ULP track
is destroyed.

Bug 1029796

Change-Id: I34411165e444665cc3ae81a26164ec1d41a85b21

AudioFlinger: Initialize volume as -1.0

Initialize mLeftVolFloat and mRightVolFloat as -1.0 instead of 0. It
is needed so that AudioFlinger applies 0 volume if volume was set to 0
during last streams playback and a direct output stream is played next.
With current code AudioFlinger does not apply any volume to libaudio
for such scenarios since current volume is initialized as 0.

Bug 1033072

Change-Id: I1ea3bbdc82be7793859476a02504cb1c40cc322a

AudioFlinger/AudioTrack: add support for LR Volume for ULP

LR (Left/Right) volume is applied in direct path with some delay
(due to large buffering involved), this causes a delay in ramping
up the volume of an already playing ULP stream after call ends.
This fixes the issue by applying the LR volume immediately when
it gets conveyed from Audio Track to AudioFlinger

Bug: 1015395
Change-Id: Ifdef5ffe44b20892ea8a048b1912937d287bb869

audioflinger: don't apply negative volume

when calling setvolume on flinger from audiotrack
we give volume as -1, this is just a dummy value and
function is called only to apply LR volume with main volume
remaining same. Also check if ulp is on by checking the
stream format instead of active ulp track variable.

Bug 1015395

Change-Id: Icfd7a17aa4e3828dffb17ba8d81716556e997ac3

AudioTrack: Print obtainbuffer timeout for non-ULP streams only

For ULP streams once full libaudio buffer is queued it is expected for
audiotrack to not get output buffer from audioflinger for several secs.
So don't print the obtain buffer warning messages in such case.

Bug 1000042
Reviewed-on: http://git-master/r/113464

Change-Id: I5771221a6719b619fa548e25d4360979c87132c1

audioflinger: inform libaudio when effects are applied to ulp

inform libaudio when effects are applied to ulp stream so that
ulp path is closed and non ulp path is opened and effects will
be applied to non ulp path

Bug 1023276

Change-Id: I394cb5f931188f4a93a39d782c42129b43cc8043

audioflinger: Always allow setparam for NV custom params

Bug 968814

Change-Id: Ia91fbf0182866eaf38d5cf03fe62743bc3b1fc1d
---
 include/media/AudioTrack.h                         |    1 +
 include/media/IMediaPlayerService.h                |    2 +
 media/libmedia/AudioTrack.cpp                      |   21 ++-
 media/libmediaplayerservice/MediaPlayerService.cpp |    4 +-
 services/audioflinger/AudioFlinger.cpp             |  189 +++++++++++++++++---
 services/audioflinger/AudioFlinger.h               |    7 +-
 6 files changed, 193 insertions(+), 31 deletions(-)

diff --git a/include/media/AudioTrack.h b/include/media/AudioTrack.h
index 34108b3..acf3ab9 100644
--- a/include/media/AudioTrack.h
+++ b/include/media/AudioTrack.h
@@ -536,6 +536,7 @@ protected:
     bool                    mIsTimed;
     int                     mPreviousPriority;          // before start()
     SchedPolicy             mPreviousSchedulingGroup;
+    audio_io_handle_t       mulpoutput;
 };
 
 class TimedAudioTrack : public AudioTrack
diff --git a/include/media/IMediaPlayerService.h b/include/media/IMediaPlayerService.h
index 7a89135..cd1119b 100644
--- a/include/media/IMediaPlayerService.h
+++ b/include/media/IMediaPlayerService.h
@@ -31,6 +31,8 @@
 
 namespace android {
 
+#define FRAMEWORK_HAS_ULP_AUDIO_SUPPORT 1
+
 struct ICrypto;
 struct IHDCP;
 class IMediaRecorder;
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 362d022..5e0c835 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -303,6 +303,11 @@ status_t AudioTrack::set(
 
     mStatus = NO_ERROR;
 
+    if (audio_is_ulp_support(format))
+        mulpoutput = output;
+    else
+        mulpoutput = 0;
+
     mStreamType = streamType;
     mFormat = format;
     mChannelMask = channelMask;
@@ -515,6 +520,13 @@ bool AudioTrack::muted() const
 
 status_t AudioTrack::setVolume(float left, float right)
 {
+    const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+
+    if (audioFlinger == 0) {
+        ALOGE("Could not get audioflinger");
+        return NO_INIT;
+    }
+
     if (left < 0.0f || left > 1.0f || right < 0.0f || right > 1.0f) {
         return BAD_VALUE;
     }
@@ -525,6 +537,9 @@ status_t AudioTrack::setVolume(float left, float right)
 
     mCblk->setVolumeLR((uint32_t(uint16_t(right * 0x1000)) << 16) | uint16_t(left * 0x1000));
 
+    if (mulpoutput)
+        audioFlinger->setStreamVolume(mStreamType, -1.0, mulpoutput);
+
     return NO_ERROR;
 }
 
@@ -994,8 +1009,10 @@ status_t AudioTrack::obtainBuffer(Buffer* audioBuffer, int32_t waitCount)
                     // timing out when a loop has been set and we have already written upto loop end
                     // is a normal condition: no need to wake AudioFlinger up.
                     if (cblk->user < cblk->loopEnd) {
-                        ALOGW(   "obtainBuffer timed out (is the CPU pegged?) %p name=%#x"
-                                "user=%08x, server=%08x", this, cblk->mName, cblk->user, cblk->server);
+                        // Don't print the warning for ULP streams as it is an expected behavior
+                        if (!audio_is_ulp_support(mFormat))
+                            ALOGW(   "obtainBuffer timed out (is the CPU pegged?) %p name=%#x"
+                                     "user=%08x, server=%08x", this, cblk->mName, cblk->user, cblk->server);
                         //unlock cblk mutex before calling mAudioTrack->start() (see issue #1617140)
                         cblk->lock.unlock();
                         result = mAudioTrack->start();
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index 9bedff1..5e67959 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -1656,9 +1656,9 @@ void MediaPlayerService::AudioOutput::CallbackWrapper(
     size_t actualSize = (*me->mCallback)(
             me, buffer->raw, buffer->size, me->mCallbackCookie);
 
-    if (actualSize == 0 && buffer->size > 0 && me->mNextOutput == NULL) {
+    if (audio_is_linear_pcm(buffer->format) && actualSize == 0 && buffer->size > 0 && me->mNextOutput == NULL) {
         // We've reached EOS but the audio track is not stopped yet,
-        // keep playing silence.
+        // keep playing silence for pcm streams.
 
         memset(buffer->raw, 0, buffer->size);
         actualSize = buffer->size;
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 6a35053..264d640 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -117,6 +117,12 @@ static const int8_t kMaxTrackStartupRetries = 50;
 // be released as quickly as possible.
 static const int8_t kMaxTrackRetriesDirect = 2;
 
+// for ulp track it is very common for audioflinger to get starved
+// because HAL consumes data as fast as possible and if parser is not fast
+// enough audioflinger will be starved. Use higher retry count for ULP to
+// ensure audioflinger does not give up easily in starvation condition.
+static const int8_t kMaxTrackRetriesUlp = 50;
+
 static const int kDumpLockRetries = 50;
 static const int kDumpLockSleepUs = 20000;
 
@@ -770,8 +776,20 @@ bool AudioFlinger::masterMute_l() const
 status_t AudioFlinger::setStreamVolume(audio_stream_type_t stream, float value,
         audio_io_handle_t output)
 {
+    PlaybackThread *thread = NULL;
+    bool isulpon = false;
+
+    AutoMutex lock(mLock);
+    if (output) {
+        thread = checkPlaybackThread_l(output);
+        if (thread == NULL)
+            return BAD_VALUE;
+        else
+            isulpon = audio_is_ulp_support(thread->format());
+    }
+
     // check calling permissions
-    if (!settingsAllowed()) {
+    if ((!isulpon) && (!settingsAllowed())) {
         return PERMISSION_DENIED;
     }
 
@@ -780,16 +798,8 @@ status_t AudioFlinger::setStreamVolume(audio_stream_type_t stream, float value,
         return BAD_VALUE;
     }
 
-    AutoMutex lock(mLock);
-    PlaybackThread *thread = NULL;
-    if (output) {
-        thread = checkPlaybackThread_l(output);
-        if (thread == NULL) {
-            return BAD_VALUE;
-        }
-    }
-
-    mStreamTypes[stream].volume = value;
+    if (value >= 0)
+        mStreamTypes[stream].volume = value;
 
     if (thread == NULL) {
         for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
@@ -856,11 +866,17 @@ bool AudioFlinger::streamMute(audio_stream_type_t stream) const
 
 status_t AudioFlinger::setParameters(audio_io_handle_t ioHandle, const String8& keyValuePairs)
 {
+    status_t result;
     ALOGV("setParameters(): io %d, keyvalue %s, tid %d, calling pid %d",
             ioHandle, keyValuePairs.string(), gettid(), IPCThreadState::self()->getCallingPid());
-    // check calling permissions
-    if (!settingsAllowed()) {
-        return PERMISSION_DENIED;
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 value;
+
+    // Allow NV custom parameters independent of permission settings
+    if ((param.size() > 1) || !strstr(keyValuePairs, "nv_param_")) {
+        if (!settingsAllowed()) {
+            return PERMISSION_DENIED;
+        }
     }
 
     // ioHandle == 0 means the parameters are global to the audio hardware interface
@@ -878,8 +894,6 @@ status_t AudioFlinger::setParameters(audio_io_handle_t ioHandle, const String8&
             mHardwareStatus = AUDIO_HW_IDLE;
         }
         // disable AEC and NS if the device is a BT SCO headset supporting those pre processings
-        AudioParameter param = AudioParameter(keyValuePairs);
-        String8 value;
         if (param.get(String8(AUDIO_PARAMETER_KEY_BT_NREC), value) == NO_ERROR) {
             bool btNrecIsOff = (value == AUDIO_PARAMETER_VALUE_OFF);
             if (mBtNrecIsOff != btNrecIsOff) {
@@ -934,7 +948,19 @@ status_t AudioFlinger::setParameters(audio_io_handle_t ioHandle, const String8&
         }
     }
     if (thread != 0) {
-        return thread->setParameters(keyValuePairs);
+        if ((thread->mType == ThreadBase::DIRECT) && audio_is_ulp_support(thread->mFormat)) {
+            AutoMutex lock(mHardwareLock);
+
+            mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+            /* Notify libaudio the io handle for which setParam is called */
+            param.addInt(String8("nv_param_io_handle"), (int)ioHandle);
+            audio_hw_device_t *dev = mPrimaryHardwareDev->hwDevice();
+            result = dev->set_parameters(dev, param.toString().string());
+            mHardwareStatus = AUDIO_HW_IDLE;
+        } else
+            result = thread->setParameters(keyValuePairs);
+
+        return result;
     }
     return BAD_VALUE;
 }
@@ -1899,6 +1925,39 @@ uint32_t AudioFlinger::PlaybackThread::latency_l() const
     }
 }
 
+status_t AudioFlinger::PlaybackThread::setUlpStreamVolume()
+{
+    if ((mType == DIRECT) && audio_is_ulp_support(mFormat)) {
+        float left = 0, right = 0;
+
+        if (mUlpActiveTrack == 0)
+            return NO_INIT;
+
+        Track* const track = mUlpActiveTrack.get();
+        audio_track_cblk_t* cblk = track->cblk();
+
+        if (track->isMuted() || mMasterMute || track->isPausing() ||
+            mStreamTypes[track->streamType()].mute) {
+            left = right = 0;
+        }
+        else {
+            float typeVolume = mStreamTypes[track->streamType()].volume;
+            float v = mMasterVolume * typeVolume;
+            uint32_t vlr = cblk->getVolumeLR();
+            float v_clamped = v * (vlr & 0xFFFF);
+            if (v_clamped > MAX_GAIN) v_clamped = MAX_GAIN;
+            left = v_clamped/MAX_GAIN;
+            v_clamped = v * (vlr >> 16);
+            if (v_clamped > MAX_GAIN) v_clamped = MAX_GAIN;
+            right = v_clamped/MAX_GAIN;
+        }
+
+        return mOutput->stream->set_volume(mOutput->stream, left, right);
+    }
+
+    return INVALID_OPERATION;
+}
+
 void AudioFlinger::PlaybackThread::setMasterVolume(float value)
 {
     Mutex::Autolock _l(mLock);
@@ -1909,6 +1968,9 @@ void AudioFlinger::PlaybackThread::setMasterVolume(float value)
     } else {
         mMasterVolume = value;
     }
+
+    if ((mType == DIRECT) && audio_is_ulp_support(mFormat))
+        setUlpStreamVolume();
 }
 
 void AudioFlinger::PlaybackThread::setMasterMute(bool muted)
@@ -1921,18 +1983,30 @@ void AudioFlinger::PlaybackThread::setMasterMute(bool muted)
     } else {
         mMasterMute = muted;
     }
+
+    if ((mType == DIRECT) && audio_is_ulp_support(mFormat))
+        setUlpStreamVolume();
 }
 
 void AudioFlinger::PlaybackThread::setStreamVolume(audio_stream_type_t stream, float value)
 {
     Mutex::Autolock _l(mLock);
-    mStreamTypes[stream].volume = value;
+
+    if (value >= 0)
+        mStreamTypes[stream].volume = value;
+
+    if ((mType == DIRECT) && audio_is_ulp_support(mFormat))
+        setUlpStreamVolume();
+
 }
 
 void AudioFlinger::PlaybackThread::setStreamMute(audio_stream_type_t stream, bool muted)
 {
     Mutex::Autolock _l(mLock);
     mStreamTypes[stream].mute = muted;
+    if ((mType == DIRECT) && audio_is_ulp_support(mFormat))
+        setUlpStreamVolume();
+
 }
 
 float AudioFlinger::PlaybackThread::streamVolume(audio_stream_type_t stream) const
@@ -1956,6 +2030,8 @@ status_t AudioFlinger::PlaybackThread::addTrack_l(const sp<Track>& track)
         track->mResetDone = false;
         track->mPresentationCompleteFrames = 0;
         mActiveTracks.add(track);
+        if (audio_is_ulp_support(mFormat) && (mUlpActiveTrack == 0))
+            mUlpActiveTrack = track;
         if (track->mainBuffer() != mMixBuffer) {
             sp<EffectChain> chain = getEffectChain_l(track->sessionId());
             if (chain != 0) {
@@ -2592,9 +2668,17 @@ bool AudioFlinger::PlaybackThread::threadLoop()
             if (CC_UNLIKELY((!mActiveTracks.size() && systemTime() > standbyTime) ||
                         isSuspended())) {
                 if (!mStandby) {
-
-                    threadLoop_standby();
-
+                    if (!audio_is_ulp_support(mFormat))
+                        threadLoop_standby();
+                    else {
+                        /* For ULP stream standby can take long time to complete
+                        So release lock while standby is executing */
+                        mLock.unlock();
+                        threadLoop_standby();
+                        mLock.lock();
+                        if (mUlpActiveTrack != 0)
+                            mUlpActiveTrack.clear();
+                    }
                     mStandby = true;
                 }
 
@@ -2710,6 +2794,8 @@ if (mType == MIXER) {
         // put output stream into standby mode
         if (!mStandby) {
             mOutput->stream->common.standby(&mOutput->stream->common);
+            if (mUlpActiveTrack != 0)
+                mUlpActiveTrack.clear();
         }
     }
 
@@ -2791,13 +2877,20 @@ void AudioFlinger::PlaybackThread::threadLoop_write()
         } else {
             bytesWritten = framesWritten;
         }
+        if (bytesWritten > 0) mBytesWritten += mixBufferSize;
     // otherwise use the HAL / AudioStreamOut directly
     } else {
         // Direct output thread.
-        bytesWritten = (int)mOutput->stream->write(mOutput->stream, mMixBuffer, mixBufferSize);
+        // Ensure zero padding is not introduced for non-PCM stream
+        if (audio_is_linear_pcm(mFormat)) {
+            bytesWritten = (int)mOutput->stream->write(mOutput->stream, mMixBuffer, mixBufferSize);
+            if (bytesWritten > 0) mBytesWritten += mixBufferSize;
+        } else {
+            bytesWritten = (int)mOutput->stream->write(mOutput->stream, mMixBuffer, mixBufferDataSize);
+            if (bytesWritten > 0) mBytesWritten += mixBufferDataSize;
+        }
     }
 
-    if (bytesWritten > 0) mBytesWritten += mixBufferSize;
     mNumWrites++;
     mInWrite = false;
 }
@@ -3410,6 +3503,7 @@ The parameters that affect these derived values are:
 void AudioFlinger::PlaybackThread::cacheParameters_l()
 {
     mixBufferSize = mNormalFrameCount * mFrameSize;
+    mixBufferDataSize = 0;
     activeSleepTime = activeSleepTimeUs();
     idleSleepTime = idleSleepTimeUs();
 }
@@ -3735,7 +3829,7 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::DirectOutputThread::prep
 
             if (track->mFillingUpStatus == Track::FS_FILLED) {
                 track->mFillingUpStatus = Track::FS_ACTIVE;
-                mLeftVolFloat = mRightVolFloat = 0;
+                mLeftVolFloat = mRightVolFloat = -1.0;
                 if (track->mState == TrackBase::RESUMING) {
                     track->mState = TrackBase::ACTIVE;
                 }
@@ -3782,7 +3876,11 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::DirectOutputThread::prep
             }
 
             // reset retry count
-            track->mRetryCount = kMaxTrackRetriesDirect;
+            if (audio_is_ulp_support(mFormat))
+                track->mRetryCount = kMaxTrackRetriesUlp;
+            else
+                track->mRetryCount = kMaxTrackRetriesDirect;
+
             mActiveTrack = t;
             mixerStatus = MIXER_TRACKS_READY;
         } else {
@@ -3801,6 +3899,14 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::DirectOutputThread::prep
                 size_t audioHALFrames = (latency_l() * mSampleRate) / 1000;
                 size_t framesWritten =
                         mBytesWritten / audio_stream_frame_size(&mOutput->stream->common);
+
+                /* For non-PCM format if audiotrack has already paused/stopped it will send
+                   no more data. Since for non-PCM format we don't send silence data to HAL
+                   mBytesWritten will not further increase and presentationComplete() will
+                   always return false. So set audioHALFrames to zero for non-PCM format */
+                if (!audio_is_linear_pcm(mFormat))
+                    audioHALFrames = 0;
+
                 if (mStandby || track->presentationComplete(framesWritten, audioHALFrames)) {
                     if (track->isStopped()) {
                         track->reset();
@@ -3843,6 +3949,7 @@ void AudioFlinger::DirectOutputThread::threadLoop_mix()
     AudioBufferProvider::Buffer buffer;
     size_t frameCount = mFrameCount;
     int8_t *curBuf = (int8_t *)mMixBuffer;
+    mixBufferDataSize = 0;
     // output audio to hardware
     while (frameCount) {
         buffer.frameCount = frameCount;
@@ -3853,6 +3960,7 @@ void AudioFlinger::DirectOutputThread::threadLoop_mix()
         }
         memcpy(curBuf, buffer.raw, buffer.frameCount * mFrameSize);
         frameCount -= buffer.frameCount;
+        mixBufferDataSize += buffer.frameCount * mFrameSize;
         curBuf += buffer.frameCount * mFrameSize;
         mActiveTrack->releaseBuffer(&buffer);
     }
@@ -7478,6 +7586,10 @@ sp<IEffect> AudioFlinger::createEffect(pid_t pid,
     status_t lStatus = NO_ERROR;
     sp<EffectHandle> handle;
     effect_descriptor_t desc;
+    bool is_ulp_session;
+    const char* is_ulp_active;
+    int retrycount;
+    AudioParameter param = AudioParameter();
 
     ALOGV("createEffect pid %d, effectClient %p, priority %d, sessionId %d, io %d",
             pid, effectClient.get(), priority, sessionId, io);
@@ -7514,6 +7626,33 @@ sp<IEffect> AudioFlinger::createEffect(pid_t pid,
         }
     }
 
+    is_ulp_session = false;
+    for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
+        sp<PlaybackThread> t = mPlaybackThreads.valueAt(i);
+        if (audio_is_ulp_support(t->format())) {
+            if(t->hasAudioSession(sessionId)) {
+                is_ulp_session = true;
+                break;
+            }
+        }
+    }
+
+    if (is_ulp_session) {
+        param.addInt(String8( "nv_param_effects_count"),
+            (int)1);
+        setParameters(0, param.toString());
+        /*sleep for 50ms for ulp to be disabled*/
+        usleep(50000);
+        is_ulp_active = (getParameters(0, String8("nv_param_ulp_active"))).string();
+        retrycount = 0;
+        while (!strcmp(is_ulp_active,"1") && retrycount != 5) {
+            retrycount++;
+           /*sleep for another 50ms for ulp to be disabled*/
+            usleep(50000);
+            is_ulp_active = (getParameters(0, String8("nv_param_ulp_active"))).string();
+        }
+    }
+
     {
         Mutex::Autolock _l(mLock);
 
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index 49e2b2c..f15b41a 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -1121,8 +1121,7 @@ public:
 
                     virtual status_t setSyncEvent(const sp<SyncEvent>& event);
                     virtual bool     isValidSyncEvent(const sp<SyncEvent>& event) const;
-                            void     invalidateTracks(audio_stream_type_t streamType);
-
+                    void     invalidateTracks(audio_stream_type_t streamType);
 
     protected:
         int16_t*                        mMixBuffer;
@@ -1181,10 +1180,13 @@ public:
 
         void        readOutputParameters();
 
+        status_t    setUlpStreamVolume();
+
         virtual void dumpInternals(int fd, const Vector<String16>& args);
         void        dumpTracks(int fd, const Vector<String16>& args);
 
         SortedVector< sp<Track> >       mTracks;
+        sp<Track>                       mUlpActiveTrack;
         // mStreamTypes[] uses 1 additional stream type internally for the OutputTrack used by DuplicatingThread
         stream_type_t                   mStreamTypes[AUDIO_STREAM_CNT + 1];
         AudioStreamOut                  *mOutput;
@@ -1198,6 +1200,7 @@ public:
         // FIXME rename these former local variables of threadLoop to standard "m" names
         nsecs_t                         standbyTime;
         size_t                          mixBufferSize;
+        size_t                          mixBufferDataSize;
 
         // cached copies of activeSleepTimeUs() and idleSleepTimeUs() made by cacheParameters_l()
         uint32_t                        activeSleepTime;
-- 
1.7.1

