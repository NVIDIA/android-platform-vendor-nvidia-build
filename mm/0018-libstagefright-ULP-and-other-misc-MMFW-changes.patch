From 03969ed38281acc9575f26ce1ec26b180c0b42ad Mon Sep 17 00:00:00 2001
From: aarti jadhav-gaikwad <agaikwad@nvidia.com>
Date: Thu, 21 Jun 2012 19:39:42 +0530
Subject: [PATCH] libstagefright : ULP and other misc MMFW changes

Integraed the changes regarding auidio ULP
playback.

This contains following Commits on ICS:
http://git-master/r/#change,95575
http://git-master/r/#change,94870
http://git-master/r/#change,101674
http://git-master/r/#change,101934
http://git-master/r/#change,114158

Change-Id: I762d0236e1d30b1812f052d9c5d2ac4aa8be1586
---
 include/media/MediaPlayerInterface.h               |    3 +-
 include/media/stagefright/AudioPlayer.h            |    4 +
 include/media/stagefright/DataSource.h             |    1 +
 include/media/stagefright/FileSource.h             |    2 +
 media/libmedia/AudioTrack.cpp                      |   18 ++++-
 media/libmediaplayerservice/MediaPlayerService.cpp |    7 ++-
 media/libmediaplayerservice/MediaPlayerService.h   |    3 +-
 media/libstagefright/AudioPlayer.cpp               |   33 +++++++-
 media/libstagefright/AwesomePlayer.cpp             |   82 ++++++++++++++++++-
 media/libstagefright/FileSource.cpp                |    4 +
 media/libstagefright/include/AwesomePlayer.h       |    7 ++
 .../libstagefright/matroska/MatroskaExtractor.cpp  |    6 ++
 12 files changed, 156 insertions(+), 14 deletions(-)

diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index b7bee3f..37eb3ae 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (C) 2007-2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -90,6 +90,7 @@ public:
         virtual status_t    getPosition(uint32_t *position) const = 0;
         virtual status_t    getFramesWritten(uint32_t *frameswritten) const = 0;
         virtual int         getSessionId() const = 0;
+        virtual int         getStreamType() {return AUDIO_STREAM_DEFAULT;};
 
         // If no callback is specified, use the "write" API below to submit
         // audio data.
diff --git a/include/media/stagefright/AudioPlayer.h b/include/media/stagefright/AudioPlayer.h
index 1dc408f..f5dfd85 100644
--- a/include/media/stagefright/AudioPlayer.h
+++ b/include/media/stagefright/AudioPlayer.h
@@ -65,6 +65,8 @@ public:
     bool isSeeking();
     bool reachedEOS(status_t *finalStatus);
 
+    void enableAudioULP(bool enabledAudioULP);
+
     status_t setPlaybackRatePermille(int32_t ratePermille);
 
 private:
@@ -77,6 +79,7 @@ private:
     int mSampleRate;
     int64_t mLatencyUs;
     size_t mFrameSize;
+    audio_format_t mAudioFormat;
 
     Mutex mLock;
     int64_t mNumFramesPlayed;
@@ -91,6 +94,7 @@ private:
     int64_t mSeekTimeUs;
 
     bool mStarted;
+    bool mEnabledAudioULP;
 
     bool mIsFirstBuffer;
     status_t mFirstBufferResult;
diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index 8c539ae..1b21a83 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -49,6 +49,7 @@ public:
         kStreamedFromLocalHost = 2,
         kIsCachingDataSource   = 4,
         kIsHTTPBasedSource     = 8,
+        kIsLocalDataSource     = 16
     };
 
     static sp<DataSource> CreateFromURI(
diff --git a/include/media/stagefright/FileSource.h b/include/media/stagefright/FileSource.h
index d994cb3..396f1d2 100644
--- a/include/media/stagefright/FileSource.h
+++ b/include/media/stagefright/FileSource.h
@@ -42,6 +42,8 @@ public:
 
     virtual void getDrmInfo(sp<DecryptHandle> &handle, DrmManagerClient **client);
 
+    virtual uint32_t flags();
+
 protected:
     virtual ~FileSource();
 
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 362d022..4a97484 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -763,6 +763,15 @@ status_t AudioTrack::createTrack_l(
         return NO_INIT;
     }
 
+    int afSampleRate;
+    if (AudioSystem::getOutputSamplingRate(&afSampleRate, streamType) != NO_ERROR) {
+        return NO_INIT;
+    }
+    int afFrameCount;
+    if (AudioSystem::getOutputFrameCount(&afFrameCount, streamType) != NO_ERROR) {
+        return NO_INIT;
+    }
+
     uint32_t afLatency;
     if (AudioSystem::getLatency(output, streamType, &afLatency) != NO_ERROR) {
         return NO_INIT;
@@ -796,8 +805,13 @@ status_t AudioTrack::createTrack_l(
                 return NO_INIT;
             }
             frameCount = afFrameCount;
-        }
-
+        } else {
+            uint32_t minBufCount = afLatency / ((1000 * afFrameCount)/afSampleRate);
+            if (minBufCount < 2) minBufCount = 2;
+            int minFrameCount = afFrameCount*minBufCount;
+            frameCount = minFrameCount;
+            mNotificationFramesAct = frameCount/2;
+       }
     } else if (sharedBuffer != 0) {
 
         // Ensure that buffer alignment matches channelCount
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index 9bedff1..49fc044 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -1,6 +1,6 @@
 /*
 **
-** Copyright 2008, The Android Open Source Project
+** Copyright 2008-2012, The Android Open Source Project
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -1673,6 +1673,11 @@ int MediaPlayerService::AudioOutput::getSessionId() const
     return mSessionId;
 }
 
+int MediaPlayerService::AudioOutput::getStreamType()
+{
+    return mStreamType;
+}
+
 #undef LOG_TAG
 #define LOG_TAG "AudioCache"
 MediaPlayerService::AudioCache::AudioCache(const char* name) :
diff --git a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
index fd648df..b1cd99b 100644
--- a/media/libmediaplayerservice/MediaPlayerService.h
+++ b/media/libmediaplayerservice/MediaPlayerService.h
@@ -1,6 +1,6 @@
 /*
 **
-** Copyright 2008, The Android Open Source Project
+** Copyright 2008-2012, The Android Open Source Project
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -89,6 +89,7 @@ class MediaPlayerService : public BnMediaPlayerService
         virtual status_t        getPosition(uint32_t *position) const;
         virtual status_t        getFramesWritten(uint32_t *frameswritten) const;
         virtual int             getSessionId() const;
+        virtual int             getStreamType();
 
         virtual status_t        open(
                 uint32_t sampleRate, int channelCount, audio_channel_mask_t channelMask,
diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index 5a92a34..90a7cb9 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -41,6 +41,7 @@ AudioPlayer::AudioPlayer(
       mSampleRate(0),
       mLatencyUs(0),
       mFrameSize(0),
+      mAudioFormat(AUDIO_FORMAT_PCM_16_BIT),
       mNumFramesPlayed(0),
       mNumFramesPlayedSysTimeUs(ALooper::GetNowUs()),
       mPositionTimeMediaUs(-1),
@@ -49,6 +50,7 @@ AudioPlayer::AudioPlayer(
       mReachedEOS(false),
       mFinalStatus(OK),
       mStarted(false),
+      mEnabledAudioULP(false),
       mIsFirstBuffer(false),
       mFirstBufferResult(OK),
       mFirstBuffer(NULL),
@@ -110,7 +112,6 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
     const char *mime;
     bool success = format->findCString(kKeyMIMEType, &mime);
     CHECK(success);
-    CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
 
     success = format->findInt32(kKeySampleRate, &mSampleRate);
     CHECK(success);
@@ -126,10 +127,21 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
         channelMask = CHANNEL_MASK_USE_CHANNEL_ORDER;
     }
 
+    if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG) ||
+        !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II)) {
+        // sending compressed audio as it is
+        CHECK(numChannels == 2);
+        mAudioFormat = AUDIO_FORMAT_MP3;
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
+        // sending compressed audio as it is
+        CHECK(numChannels == 2);
+        mAudioFormat = AUDIO_FORMAT_AAC;
+    }
+
     if (mAudioSink.get() != NULL) {
 
         status_t err = mAudioSink->open(
-                mSampleRate, numChannels, channelMask, AUDIO_FORMAT_PCM_16_BIT,
+                mSampleRate, numChannels, channelMask, mAudioFormat,
                 DEFAULT_AUDIOSINK_BUFFERCOUNT,
                 &AudioPlayer::AudioSinkCallback,
                 this,
@@ -162,7 +174,7 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
         }
 
         mAudioTrack = new AudioTrack(
-                AUDIO_STREAM_MUSIC, mSampleRate, AUDIO_FORMAT_PCM_16_BIT, audioMask,
+                AUDIO_STREAM_MUSIC, mSampleRate, mAudioFormat, audioMask,
                 0, AUDIO_OUTPUT_FLAG_NONE, &AudioCallback, this, 0);
 
         if ((err = mAudioTrack->initCheck()) != OK) {
@@ -196,7 +208,7 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
 void AudioPlayer::pause(bool playPendingSamples) {
     CHECK(mStarted);
 
-    if (playPendingSamples) {
+    if ((playPendingSamples) && (mEnabledAudioULP == false)) {
         if (mAudioSink.get() != NULL) {
             mAudioSink->stop();
         } else {
@@ -206,6 +218,10 @@ void AudioPlayer::pause(bool playPendingSamples) {
         mNumFramesPlayed = 0;
         mNumFramesPlayedSysTimeUs = ALooper::GetNowUs();
     } else {
+        if(mEnabledAudioULP) {
+            String8 key = String8("nv_param_avp_decode_pause=1");
+            AudioSystem::setParameters(NULL,key);
+        }
         if (mAudioSink.get() != NULL) {
             mAudioSink->pause();
         } else {
@@ -219,6 +235,11 @@ void AudioPlayer::pause(bool playPendingSamples) {
 void AudioPlayer::resume() {
     CHECK(mStarted);
 
+    if(mEnabledAudioULP) {
+        String8 key = String8("nv_param_avp_decode_pause=0");
+        AudioSystem::setParameters(NULL,key);
+    }
+
     if (mAudioSink.get() != NULL) {
         mAudioSink->start();
     } else {
@@ -594,4 +615,8 @@ status_t AudioPlayer::seekTo(int64_t time_us) {
     return OK;
 }
 
+void AudioPlayer::enableAudioULP(bool enabledAudioULP) {
+    mEnabledAudioULP = enabledAudioULP;
+}
+
 }
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 6b8adca..fb70b67 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2009-2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -35,6 +35,7 @@
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
 #include <media/IMediaPlayerService.h>
+#include <media/AudioSystem.h>
 #include <media/stagefright/foundation/hexdump.h>
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/timedtext/TimedTextDriver.h>
@@ -64,6 +65,8 @@ static int64_t kLowWaterMarkUs = 2000000ll;  // 2secs
 static int64_t kHighWaterMarkUs = 5000000ll;  // 5secs
 static const size_t kLowWaterMarkBytes = 40000;
 static const size_t kHighWaterMarkBytes = 200000;
+bool AwesomePlayer::mEnabledAudioULP = false;
+Mutex AwesomePlayer::mAudioULP;
 
 struct AwesomeEvent : public TimedEventQueue::Event {
     AwesomeEvent(
@@ -194,7 +197,10 @@ AwesomePlayer::AwesomePlayer()
       mVideoBuffer(NULL),
       mDecryptHandle(NULL),
       mLastVideoTimeUs(-1),
-      mTextDriver(NULL) {
+      mTextDriver(NULL),
+      mStreamSupportsULP(false),
+      mOwnerAudioULP(false),
+      mDataSourceFlags(0) {
     CHECK_EQ(mClient.connect(), (status_t)OK);
 
     DataSource::RegisterDefaultSniffers();
@@ -411,6 +417,8 @@ status_t AwesomePlayer::setDataSource_l(
     setProfileFlags();
 #endif
 
+    mDataSourceFlags = dataSource->flags();
+
     if (extractor->getDrmFlag()) {
         checkDrmStatus(dataSource);
     }
@@ -469,6 +477,7 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
 
     bool haveAudio = false;
     bool haveVideo = false;
+    int32_t numChannels = 0, sampleRate = 0, ulpSupported = 0;
     for (size_t i = 0; i < extractor->countTracks(); ++i) {
         sp<MetaData> meta = extractor->getTrackMetaData(i);
 
@@ -516,6 +525,8 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
             setAudioSource(extractor->getTrack(i));
             haveAudio = true;
             mActiveAudioTrackIndex = i;
+            meta->findInt32(kKeyChannelCount, &numChannels);
+            meta->findInt32(kKeySampleRate, &sampleRate);
 #ifdef PROFILING
             meta->findInt32(kKeySampleRate, &mProfileStats->mInSamplerate);
             meta->findInt32(kKeyChannelCount, &mProfileStats->mInChannels);
@@ -557,6 +568,19 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
         }
     }
 
+    {
+        // Check if libaudio supports ULP decode
+        char *paramVal;
+        String8 key = String8("nv_param_ulp_supported");
+        String8 out = AudioSystem::getParameters(NULL,key);
+        if (out.length() != 0)
+            sscanf(out.string(), "%d", &ulpSupported);
+    }
+
+    if (!haveVideo && haveAudio && ulpSupported && (numChannels == 2) && ((sampleRate == 48000) || (sampleRate == 44100))) {
+        mStreamSupportsULP = true;
+    }
+
     mExtractorFlags = extractor->flags();
 
     return OK;
@@ -633,9 +657,22 @@ void AwesomePlayer::reset_l() {
 
     mTimeSource = NULL;
 
+    if (mOwnerAudioULP) {
+        // flush the compressed data ib libaudio for asynchronous stop
+        String8 key = String8("nv_param_avp_decode_flush=1");
+        AudioSystem::setParameters(NULL,key);
+    }
+    mOffsetTimeUs = 0;
+
     delete mAudioPlayer;
     mAudioPlayer = NULL;
 
+    if (mOwnerAudioULP) {
+        Mutex::Autolock autoLock(AwesomePlayer::mAudioULP);
+        AwesomePlayer::mEnabledAudioULP = false;
+        mOwnerAudioULP = false;
+    }
+
     if (mTextDriver != NULL) {
         delete mTextDriver;
         mTextDriver = NULL;
@@ -995,9 +1032,9 @@ status_t AwesomePlayer::play_l() {
                 } else {
                     allowDeepBuffering = false;
                 }
-
                 mAudioPlayer = new AudioPlayer(mAudioSink, allowDeepBuffering, this);
                 mAudioPlayer->setSource(mAudioSource);
+                mAudioPlayer->enableAudioULP(mOwnerAudioULP);
 
                 mTimeSource = mAudioPlayer;
 
@@ -1321,6 +1358,7 @@ void AwesomePlayer::shutdownVideoDecoder_l() {
         usleep(1000);
     }
     IPCThreadState::self()->flushCommands();
+    mDataSourceFlags = 0;
     ALOGV("video decoder shutdown completed");
 }
 
@@ -1399,7 +1437,17 @@ status_t AwesomePlayer::getPosition(int64_t *positionUs) {
         Mutex::Autolock autoLock(mMiscStateLock);
         *positionUs = mVideoTimeUs;
     } else if (mAudioPlayer != NULL) {
-        *positionUs = mAudioPlayer->getMediaTimeUs();
+        if(mOwnerAudioULP)
+        {
+            uint64_t pos = 0;
+            String8 key = String8("nv_param_avp_decode_position");
+            String8 out = AudioSystem::getParameters(NULL,key);
+            if(out.length() != 0)
+                sscanf(out.string(), "%lld", &pos);
+            *positionUs = mOffsetTimeUs + pos;
+        } else {
+            *positionUs = mAudioPlayer->getMediaTimeUs();
+        }
     } else {
         *positionUs = 0;
     }
@@ -1466,7 +1514,19 @@ status_t AwesomePlayer::seekTo_l(int64_t timeUs) {
 
 void AwesomePlayer::seekAudioIfNecessary_l() {
     if (mSeeking != NO_SEEK && mVideoSource == NULL && mAudioPlayer != NULL) {
+        if((mOwnerAudioULP == true) && (mFlags & AUDIO_RUNNING)) {
+            // Pause the audio track to stop feeding compressed data to libaudio
+            mAudioPlayer->pause();
+        }
         mAudioPlayer->seekTo(mSeekTimeUs);
+        // flush buffered data in avp for ULP case
+        if(mOwnerAudioULP == true) {
+            String8 key = String8("nv_param_avp_decode_flush=1");
+            AudioSystem::setParameters(NULL,key);
+            mOffsetTimeUs = mSeekTimeUs;
+            if(mFlags & AUDIO_RUNNING)
+                mAudioPlayer->resume();
+        }
 
         mWatchForAudioSeekComplete = true;
         mWatchForAudioEOS = true;
@@ -1504,7 +1564,19 @@ status_t AwesomePlayer::initAudioDecoder() {
     const char *mime;
     CHECK(meta->findCString(kKeyMIMEType, &mime));
 
-    if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
+    if ((mStreamSupportsULP) &&
+        (mAudioSink->realtime()) &&
+        (mAudioSink->getStreamType() == AUDIO_STREAM_MUSIC) &&
+        (mDataSourceFlags & DataSource::kIsLocalDataSource) &&
+        (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG))) {
+        Mutex::Autolock autoLock(AwesomePlayer::mAudioULP);
+        if (!AwesomePlayer::mEnabledAudioULP) {
+            AwesomePlayer::mEnabledAudioULP = true;
+            mOwnerAudioULP = true;
+        }
+    }
+
+    if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW) || mOwnerAudioULP) {
         mAudioSource = mAudioTrack;
     } else {
         mAudioSource = OMXCodec::Create(
diff --git a/media/libstagefright/FileSource.cpp b/media/libstagefright/FileSource.cpp
index e510ab9..3cf5e83 100644
--- a/media/libstagefright/FileSource.cpp
+++ b/media/libstagefright/FileSource.cpp
@@ -127,6 +127,10 @@ status_t FileSource::getSize(off64_t *size) {
     return OK;
 }
 
+uint32_t FileSource::flags() {
+        return kIsLocalDataSource;
+}
+
 sp<DecryptHandle> FileSource::DrmInitialization(const char *mime) {
     Mutex::Autolock autoLock(mLock);
 
diff --git a/media/libstagefright/include/AwesomePlayer.h b/media/libstagefright/include/AwesomePlayer.h
index a4696af..d873320 100644
--- a/media/libstagefright/include/AwesomePlayer.h
+++ b/media/libstagefright/include/AwesomePlayer.h
@@ -260,6 +260,13 @@ private:
     int64_t mLastVideoTimeUs;
     TimedTextDriver *mTextDriver;
 
+    //Audio ULP
+    bool mStreamSupportsULP;
+    bool mOwnerAudioULP;
+    static bool mEnabledAudioULP;
+    static Mutex mAudioULP;
+    int64_t mOffsetTimeUs;
+
     sp<WVMExtractor> mWVMExtractor;
     sp<MediaExtractor> mExtractor;
 
diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index 8f7d12b..275e320 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -858,6 +858,12 @@ void MatroskaExtractor::addTracks() {
                     addVorbisCodecInfo(meta, codecPrivate, codecPrivateSize);
                 } else if (!strcmp("A_MPEG/L3", codecID)) {
                     meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);
+                } else if (!strcmp("A_MPEG/L2", codecID)) {
+                    meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II);
+                } else if (!strcmp("A_AC3", codecID)) {
+                    meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);
+                } else if (!strcmp("A_DTS", codecID)) {
+                    meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_DTS);
                 } else {
                     ALOGW("%s is not supported.", codecID);
                     continue;
-- 
1.7.1

