From 221643a61715121aaec11613bc9aa55b28bb51f2 Mon Sep 17 00:00:00 2001
From: Aniruddha C <aniruddhac@nvidia.com>
Date: Wed, 20 Jun 2012 18:09:15 +0530
Subject: [PATCH 23/40] HTTP & RTSP Integrations to Android J

Stability & Perf fixes from pre Android-J development for
Chromium HTTP and NuPlayer.

Integrations for following commits:
http://git-master/r/#change,90382 - Handle audio/video timestamp jumps better
http://git-master/r/#change,83373 - Add extra check for EOS
http://git-master/r/#change,95879 - Correct data types of variables.
http://git-master/r/#change,96112 - chromium_http fix getSize api

Change-Id: I9ca9ac75f49a2c64776c7dceba4ecbd3b9c66b8b

[SF Streaming] HTTP-PS Integrations to Android J

Stability & Perf fixes from pre Android-J development for
HTTP progressive streaming.

Integrations for following commits:
http://git-master/r/#change,94519 - Cancel sniff operation if reset
http://git-master/r/#change,69429 - Cancel Prepare if reset
http://git-master/r/#change,99414 - Add check in seek time precision
http://git-master/r/#change,75563 - Reset buffering notification flag
http://git-master/r/#change,68144 - Modify HighWaterMark Notification
http://git-master/r/#change,72754 - Reset PLAYING flag since cache underrun
http://git-master/r/#change,40846 - Improve buffering notifications in streaming
http://git-master/r/#change,56574 - Start AudPlayer after HighWaterMark
http://git-master/r/#change,100880 - Resume AudioPlayer if content size not present

Change-Id: I7d7529e32555f2c8b8f973a8db9fdb9810c4e968

[SF Streaming] Send EOS after all retry failures

Send EOS from NuCachedSource2 if all the trials
for http conection fail in the state when playback
is paused due to CacheUnderRun.

Bug 1033267

Change-Id: I242f4334b6c0d3863233648286b23a36518eb989

[SF Streaming] Fix ANR for large AVI files

Start the audio player when PLAYING flag is set.

Bug 1048676

Change-Id: I80e0c32b272ba386437621e1d3d52c50367ae634

[SF Streaming] Fix ANR issue during HTTP seek operation

When seek is performed for HTTP streaming, then current data
is flushed out and it may take more than 5 seconds to buffer
the data from the new offset. During this time, handle play,
pause and seek requests from the app.

Bug 1037042

Reviewed on http://git-master/r/#change,130151
(cherry-picked from 3c2175fca0af4e0b9661712a6d419e6ebb69dd00)

Change-Id: Ic1d6b07b9b9465350044cbd0ba399e132accb9b4

[SF Streaming]Fix issue related to seek in HTTP

In case of multiple seeks, no consecutive seeks
were executed if pause operation occure due to
any reason in between as no seek completion event
is sent after seek complete. Corrected the same by
modifying and adding some of the conditions.

Bug 1053720

Reviewed-on: http://git-master/r/139653
(cherry picked from commit 2ffe53a644ec07f296b6577e6c9cd0982de79ca1)

Change-Id: Ibeef856abd17011a19692a8ae25aa91a66cab32b
---
 include/media/stagefright/DataSource.h             |    5 +-
 .../nuplayer/NuPlayerRenderer.cpp                  |    8 ++
 media/libstagefright/AwesomePlayer.cpp             |   94 +++++++++++++++++--
 media/libstagefright/DataSource.cpp                |    3 +
 .../chromium_http/ChromiumHTTPDataSource.cpp       |    1 +
 media/libstagefright/chromium_http/support.cpp     |   40 ++++++++-
 media/libstagefright/chromium_http/support.h       |    7 ++
 media/libstagefright/include/AwesomePlayer.h       |    6 ++
 8 files changed, 152 insertions(+), 12 deletions(-)

diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index 1b21a83..f428e16 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -61,7 +61,7 @@ public:
             const KeyedVector<String8, String8> *headers = NULL,
             uint64_t flags = 0);
 
-    DataSource() {}
+    DataSource(): mCancelSniff(false) {}
 
     virtual status_t initCheck() const = 0;
 
@@ -92,6 +92,8 @@ public:
             const sp<DataSource> &source, String8 *mimeType,
             float *confidence, sp<AMessage> *meta);
 
+    void cancelSniffOperation() { mCancelSniff = true; }
+
     static void RegisterSniffer(SnifferFunc func);
     static void RegisterDefaultSniffers();
 
@@ -113,6 +115,7 @@ protected:
 private:
     static Mutex gSnifferMutex;
     static List<SnifferFunc> gSniffers;
+    bool mCancelSniff;
 
     DataSource(const DataSource &);
     DataSource &operator=(const DataSource &);
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index be702eb..210a807 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -353,6 +353,10 @@ void NuPlayer::Renderer::postDrainVideoQueue() {
         }
     }
 
+    // cap waits to 20ms, to account for audio timestamp discontinuities
+    if (delayUs > 20000)
+        delayUs = 20000;
+
     msg->post(delayUs);
 
     mDrainVideoQueuePending = true;
@@ -386,10 +390,14 @@ void NuPlayer::Renderer::onDrainVideoQueue() {
     mVideoLateByUs = ALooper::GetNowUs() - realTimeUs;
 
     bool tooLate = (mVideoLateByUs > 40000);
+    bool tooEarly = (mVideoLateByUs < -20000);
 
     if (tooLate) {
         ALOGV("video late by %lld us (%.2f secs)",
              mVideoLateByUs, mVideoLateByUs / 1E6);
+    } else if (tooEarly) {
+        LOGV("video too early by %lld us (%.3f secs)", -mVideoLateByUs, -mVideoLateByUs / 1E6);
+        return;
     } else {
         ALOGV("rendering video at media time %.2f secs", mediaTimeUs / 1E6);
     }
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 8e5b8af..2f0958b 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -200,7 +200,9 @@ AwesomePlayer::AwesomePlayer()
       mTextDriver(NULL),
       mStreamSupportsULP(false),
       mOwnerAudioULP(false),
-      mDataSourceFlags(0) {
+      mIsBufferingStartEventNotified(false),
+      mDataSourceFlags(0),
+      mPauseAfterSeek(false) {
     CHECK_EQ(mClient.connect(), (status_t)OK);
 
     DataSource::RegisterDefaultSniffers();
@@ -587,6 +589,14 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
 }
 
 void AwesomePlayer::reset() {
+    if (mFlags & PREPARING) {
+        LOGV("Reset called during Preparing. Aborting prepare...");
+        modifyFlags(PREPARE_CANCELLED, SET);
+
+        if (mCachedSource != NULL) {
+            mCachedSource->cancelSniffOperation();
+        }
+    }
     Mutex::Autolock autoLock(mLock);
     reset_l();
 }
@@ -640,6 +650,7 @@ void AwesomePlayer::reset_l() {
     mAudioTrack.clear();
     mVideoTrack.clear();
     mExtractor.clear();
+    mSeekPoints.clear();
 
     // Shutdown audio first, so that the respone to the reset request
     // appears to happen instantaneously as far as the user is concerned
@@ -692,6 +703,7 @@ void AwesomePlayer::reset_l() {
 
     mSeeking = NO_SEEK;
     mSeekNotificationSent = true;
+    mPauseAfterSeek = false;
     mSeekTimeUs = 0;
 
     mUri.setTo("");
@@ -814,6 +826,14 @@ void AwesomePlayer::onBufferingUpdate() {
             if (finalStatus == ERROR_END_OF_STREAM) {
                 notifyListener_l(MEDIA_BUFFERING_UPDATE, 100);
             }
+            if ((mFlags & CACHE_UNDERRUN) && !mCachedSource->isCacheFetching()) {
+                modifyFlags(CACHE_UNDERRUN, CLEAR);
+                if (mWVMExtractor == NULL) {
+                    play_l();
+                }
+                notifyListener_l(MEDIA_INFO, MEDIA_INFO_BUFFERING_END);
+                mIsBufferingStartEventNotified = false;
+            }
             if (mFlags & PREPARING) {
                 ALOGV("cache has reached EOS, prepare is done.");
 #ifdef PROFILING
@@ -909,6 +929,7 @@ void AwesomePlayer::onBufferingUpdate() {
                 sendCacheStats();
             }
             notifyListener_l(MEDIA_INFO, MEDIA_INFO_BUFFERING_START);
+            mIsBufferingStartEventNotified = true;
         } else if (!eos && cachedDurationUs < kHighWaterMarkUs
                && !(mFlags & PREPARING)
                && !(mFlags & PLAYING)) {
@@ -921,14 +942,19 @@ void AwesomePlayer::onBufferingUpdate() {
                         play_l();
                     }
                     notifyListener_l(MEDIA_INFO, MEDIA_INFO_BUFFERING_END);
+                    mIsBufferingStartEventNotified = false;
                 }
             }
         } else if (eos || cachedDurationUs > kHighWaterMarkUs) {
-            if (mFlags & CACHE_UNDERRUN) {
+            if (mFlags & CACHE_UNDERRUN || mIsBufferingStartEventNotified) {
                 modifyFlags(CACHE_UNDERRUN, CLEAR);
-                ALOGI("cache has filled up (%.2f secs), resuming.",
-                      cachedDurationUs / 1E6);
-                play_l();
+                if (mWVMExtractor == NULL) {
+                    ALOGI("cache has filled up (%.2f secs), resuming.",
+                          cachedDurationUs / 1E6);
+                    play_l();
+                }
+                notifyListener_l(MEDIA_INFO, MEDIA_INFO_BUFFERING_END);
+                mIsBufferingStartEventNotified = false;
             } else if (mFlags & PREPARING) {
                 ALOGV("cache has filled up (%.2f secs), prepare is done",
                      cachedDurationUs / 1E6);
@@ -936,6 +962,8 @@ void AwesomePlayer::onBufferingUpdate() {
 #ifdef PROFILING
                 mProfileStats->mHighWaterMarkTimeUs = ALooper::GetNowUs();
 #endif
+            } else if (!mIsBufferingStartEventNotified && (mFlags & CACHE_UNDERRUN)) {
+                mIsBufferingStartEventNotified = true;
             }
         }
     }
@@ -1014,6 +1042,11 @@ void AwesomePlayer::onStreamDone() {
 status_t AwesomePlayer::play() {
     ATRACE_CALL();
 
+    if (mPauseAfterSeek && (mCachedSource != NULL) && (mSeeking != NO_SEEK)) {
+        mPauseAfterSeek = false;
+        return OK;
+    }
+
     Mutex::Autolock autoLock(mLock);
 
     modifyFlags(CACHE_UNDERRUN, CLEAR);
@@ -1319,6 +1352,10 @@ void AwesomePlayer::initRenderer_l() {
 status_t AwesomePlayer::pause() {
     ATRACE_CALL();
 
+    if ((mCachedSource != NULL) && (mSeeking != NO_SEEK)) {
+        mPauseAfterSeek = true;
+        return OK;
+    }
     Mutex::Autolock autoLock(mLock);
 
     modifyFlags(CACHE_UNDERRUN, CLEAR);
@@ -1328,6 +1365,13 @@ status_t AwesomePlayer::pause() {
 
 status_t AwesomePlayer::pause_l(bool at_eos) {
     if (!(mFlags & PLAYING)) {
+        if (isStreamingHTTP() && mIsBufferingStartEventNotified) {
+            // This means that pause is called second time
+            // from sites like m.youtube.com while exiting.
+            // Disable the notification for play() when HighWaterMark is reached.
+            modifyFlags(CACHE_UNDERRUN, CLEAR);
+            mIsBufferingStartEventNotified = false;
+        }
         return OK;
     }
 
@@ -1506,6 +1550,12 @@ status_t AwesomePlayer::seekTo(int64_t timeUs) {
     ATRACE_CALL();
 
     if (mExtractorFlags & MediaExtractor::CAN_SEEK) {
+        if (mCachedSource != NULL && mSeeking == SEEK) {
+            // One seek is already in progress.
+            // Store this seek point and return.
+            mSeekPoints.push_back(timeUs);
+            return OK;
+        }
         Mutex::Autolock autoLock(mLock);
         return seekTo_l(timeUs);
     }
@@ -1515,7 +1565,7 @@ status_t AwesomePlayer::seekTo(int64_t timeUs) {
 }
 
 status_t AwesomePlayer::seekTo_l(int64_t timeUs) {
-    if (timeUs == ((mDurationUs/1000)*1000)) {
+    if ((mDurationUs > 0) && (timeUs >= ((mDurationUs / 1000) * 1000))) {
         timeUs = mDurationUs;
     }
 
@@ -1808,7 +1858,7 @@ void AwesomePlayer::finishSeekIfNecessary(int64_t videoTimeUs) {
         mAudioPlayer->seekTo(videoTimeUs < 0 ? mSeekTimeUs : videoTimeUs);
         mWatchForAudioSeekComplete = true;
         mWatchForAudioEOS = true;
-    } else if (!mSeekNotificationSent) {
+    } else if (!mSeekNotificationSent || mSeeking == SEEK ) {
         // If we're playing video only, report seek complete now,
         // otherwise audio player will notify us later.
         notifyListener_l(MEDIA_SEEK_COMPLETE);
@@ -1817,6 +1867,17 @@ void AwesomePlayer::finishSeekIfNecessary(int64_t videoTimeUs) {
 
     modifyFlags(FIRST_FRAME, SET);
     mSeeking = NO_SEEK;
+    if ((mCachedSource != NULL) && !mSeekPoints.empty()) {
+        const int64_t timeUs = *mSeekPoints.begin();
+        mSeekPoints.erase(mSeekPoints.begin());
+        seekTo_l(timeUs);
+    }
+
+    if (mPauseAfterSeek && (mCachedSource != NULL)) {
+        mPauseAfterSeek = false;
+        modifyFlags(CACHE_UNDERRUN, CLEAR);
+        pause_l();
+    }
 
     if (mDecryptHandle != NULL) {
         mDrmManagerClient->setPlaybackStatus(mDecryptHandle,
@@ -1966,7 +2027,9 @@ void AwesomePlayer::onVideoEvent() {
     SeekType wasSeeking = mSeeking;
     finishSeekIfNecessary(timeUs);
 
-    if (mAudioPlayer != NULL && !(mFlags & (AUDIO_RUNNING | SEEK_PREVIEW))) {
+    if (mAudioPlayer != NULL
+            && !(mFlags & (AUDIO_RUNNING | SEEK_PREVIEW))
+            && (((mCachedSource != NULL) && (mFlags & PLAYING)) || (mCachedSource == NULL))) {
         status_t err = startAudioPlayer_l();
         if (err != OK) {
             ALOGE("Starting the audio player failed w/ err %d", err);
@@ -2273,12 +2336,23 @@ void AwesomePlayer::onCheckAudioStatus() {
     if (mWatchForAudioSeekComplete && !mAudioPlayer->isSeeking()) {
         mWatchForAudioSeekComplete = false;
 
-        if (!mSeekNotificationSent) {
+        if (!mSeekNotificationSent || mSeeking == SEEK) {
             notifyListener_l(MEDIA_SEEK_COMPLETE);
             mSeekNotificationSent = true;
         }
 
         mSeeking = NO_SEEK;
+        if ((mCachedSource != NULL) && !mSeekPoints.empty()) {
+            const int64_t timeUs = *mSeekPoints.begin();
+            mSeekPoints.erase(mSeekPoints.begin());
+            seekTo_l(timeUs);
+        }
+        if (mPauseAfterSeek && (mCachedSource != NULL)) {
+            mPauseAfterSeek = false;
+            modifyFlags(CACHE_UNDERRUN, CLEAR);
+            pause_l();
+        }
+
     }
 
     status_t finalStatus;
@@ -2510,7 +2584,7 @@ status_t AwesomePlayer::finishSetDataSource_l() {
         dataSource = DataSource::CreateCachedSourceFromURI(mUri.string(), &mUriHeaders, mProfileStats->mProfFlags);
     }
 
-    if (dataSource == NULL) {
+    if (dataSource == NULL || (mFlags & PREPARE_CANCELLED)) {
         return UNKNOWN_ERROR;
     }
 
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 658ba88..43e3c26 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -81,6 +81,9 @@ bool DataSource::sniff(
     Mutex::Autolock autoLock(gSnifferMutex);
     for (List<SnifferFunc>::iterator it = gSniffers.begin();
          it != gSniffers.end(); ++it) {
+        if (mCancelSniff) {
+            return false;
+        }
         String8 newMimeType;
         float newConfidence;
         sp<AMessage> newMeta;
diff --git a/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp b/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
index 32a0ec8..a265618 100644
--- a/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
+++ b/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
@@ -230,6 +230,7 @@ status_t ChromiumHTTPDataSource::getSize(off64_t *size) {
     Mutex::Autolock autoLock(mLock);
 
     if (mContentSize < 0) {
+        *size = -1;
         return ERROR_UNSUPPORTED;
     }
 
diff --git a/media/libstagefright/chromium_http/support.cpp b/media/libstagefright/chromium_http/support.cpp
index 13ae3df..c234fbb 100644
--- a/media/libstagefright/chromium_http/support.cpp
+++ b/media/libstagefright/chromium_http/support.cpp
@@ -222,6 +222,11 @@ SfDelegate::SfDelegate()
       mReadBuffer(new net::IOBufferWithSize(8192)),
       mNumBytesRead(0),
       mNumBytesTotal(0),
+      mTotalSize(0),
+      mRangeSize(0),
+      mReadSize(0),
+      mCheckLastPage(false),
+      mCheckOffset(false),
       mDataDestination(NULL),
       mAtEOS(false) {
     InitializeNetworkThreadIfNecessary();
@@ -235,6 +240,12 @@ void SfDelegate::setOwner(ChromiumHTTPDataSource *owner) {
     mOwner = owner;
 }
 
+void SfDelegate::checkEOS() {
+    if (mReadSize == mRangeSize) {
+        mAtEOS = true;
+    }
+}
+
 void SfDelegate::setUID(uid_t uid) {
     gReqContext->setUID(uid);
 }
@@ -325,13 +336,24 @@ void SfDelegate::OnResponseStarted(net::URLRequest *request) {
 
     std::string contentType;
     request->GetResponseHeaderByName("Content-Type", &contentType);
+    int64_t expectedSize = request->GetExpectedContentSize();
 
     mOwner->onConnectionEstablished(
-            request->GetExpectedContentSize(), contentType.c_str());
+            expectedSize, contentType.c_str());
+    if (!mCheckOffset) {
+        mTotalSize = expectedSize;
+        mRangeSize = expectedSize;
+        mReadSize = 0;
+    }
 }
 
 void SfDelegate::OnReadCompleted(net::URLRequest *request, int bytes_read) {
     if (bytes_read == -1) {
+        checkEOS();
+        if (mAtEOS) {
+            mOwner->onReadCompleted(mNumBytesRead);
+            return;
+        }
         MY_LOGI(StringPrintf(
                     "OnReadCompleted, read failed, status %d",
                     request->status().status()).c_str());
@@ -363,6 +385,7 @@ void SfDelegate::OnReadCompleted(net::URLRequest *request, int bytes_read) {
            bytes_read);
 
     mNumBytesRead += bytes_read;
+    mReadSize += bytes_read;
 
     readMore(request);
 }
@@ -385,6 +408,7 @@ void SfDelegate::readMore(net::URLRequest *request) {
                    n);
 
             mNumBytesRead += n;
+            mReadSize += n;
 
             if (n == 0) {
                 mAtEOS = true;
@@ -401,6 +425,12 @@ void SfDelegate::readMore(net::URLRequest *request) {
                 mOwner->onReadCompleted(ERROR_IO);
                 return;
             }
+            if (mCheckLastPage) {
+                checkEOS();
+                if (mAtEOS){
+                    break;
+                }
+            }
 
             return;
         }
@@ -443,6 +473,8 @@ void SfDelegate::onInitiateConnection(
 
     mURLRequest = new net::URLRequest(url, this);
     mAtEOS = false;
+    mCheckLastPage = false;
+    mCheckOffset = false;
 
     mRangeRequested = false;
 
@@ -455,6 +487,9 @@ void SfDelegate::onInitiateConnection(
                     StringPrintf("Range: bytes=%lld-", offset).c_str());
 
             mRangeRequested = true;
+            mRangeSize = mTotalSize - offset;
+            mReadSize = 0;
+            mCheckOffset = true;
         }
 
         if (extra != NULL) {
@@ -527,6 +562,9 @@ void SfDelegate::onInitiateRead(void *data, size_t size) {
         mOwner->onReadCompleted(0);
         return;
     }
+    if ((mRangeSize - mReadSize) < mNumBytesTotal) {
+        mCheckLastPage = true;
+    }
 
     readMore(mURLRequest);
 }
diff --git a/media/libstagefright/chromium_http/support.h b/media/libstagefright/chromium_http/support.h
index d2c5bc0..43d1ad2 100644
--- a/media/libstagefright/chromium_http/support.h
+++ b/media/libstagefright/chromium_http/support.h
@@ -90,6 +90,7 @@ struct SfDelegate : public net::URLRequest::Delegate {
     void initiateRead(void *data, size_t size);
 
     void setOwner(ChromiumHTTPDataSource *mOwner);
+    void checkEOS();
 
     // Gets the UID of the calling process
     bool getUID(uid_t *uid) const;
@@ -130,6 +131,12 @@ private:
 
     size_t mNumBytesRead;
     size_t mNumBytesTotal;
+    int64_t mTotalSize;
+    int64_t mRangeSize;
+    int64_t mReadSize;
+    bool mCheckOffset;
+    bool mCheckLastPage;
+
     void *mDataDestination;
 
     bool mRangeRequested;
diff --git a/media/libstagefright/include/AwesomePlayer.h b/media/libstagefright/include/AwesomePlayer.h
index fe6c529..c1e5320 100644
--- a/media/libstagefright/include/AwesomePlayer.h
+++ b/media/libstagefright/include/AwesomePlayer.h
@@ -29,6 +29,7 @@
 #include <media/stagefright/TimeSource.h>
 #include <utils/threads.h>
 #include <drm/DrmManagerClient.h>
+#include <utils/List.h>
 #include "jittertool.h"
 
 namespace android {
@@ -242,6 +243,11 @@ private:
     status_t mPrepareResult;
     status_t mStreamDoneStatus;
 
+    //flag for tracking whether Buffering Start notified properly to listener
+    bool mIsBufferingStartEventNotified;
+    bool mPauseAfterSeek;
+    List<int64_t> mSeekPoints;
+
     void postVideoEvent_l(int64_t delayUs = -1);
     void postBufferingEvent_l();
     void postStreamDoneEvent_l(status_t status);
-- 
1.7.1

