From 5ab043559aa1f475b95d05e056bec0b9d063c0fa Mon Sep 17 00:00:00 2001
From: Smita Gaikwad <smitag@nvidia.com>
Date: Tue, 18 Sep 2012 10:36:42 -0400
Subject: [PATCH 1/3] [RTSP Streaming]Send poke packets after long time pause

Playback exits after long time pause as no RTP packets
are received. So send poke packets if pause time
is greater than 5sec, to resolve the issue.

Bug 1047105

Change-Id: Idc7da3a36e973a57c6d7616709801ebf7e66240e
---
 media/libstagefright/rtsp/MyHandler.h |   32 ++++++++++++++++++++++++++++++++
 1 files changed, 32 insertions(+), 0 deletions(-)

diff --git a/media/libstagefright/rtsp/MyHandler.h b/media/libstagefright/rtsp/MyHandler.h
index 3a07c5b..f063b54 100644
--- a/media/libstagefright/rtsp/MyHandler.h
+++ b/media/libstagefright/rtsp/MyHandler.h
@@ -51,6 +51,8 @@ static int64_t kAccessUnitTimeoutUs = 10000000ll;
 // stream, assume none ever will and signal EOS or switch transports.
 static int64_t kStartupTimeoutUs = 10000000ll;
 
+static int64_t kNatRefreshTimeousUs = 5000000ll; //poke packets will be sent b4 resumming if paused for more than 5sec
+
 static int64_t kDefaultKeepAliveTimeoutUs = 60000000ll;
 
 namespace android {
@@ -138,6 +140,7 @@ struct MyHandler : public AHandler {
           mSeekable(false),
           mPlayRequestSent(false),
           mPaused(false),
+          mPokeHole(false),
           mKeepAliveTimeoutUs(kDefaultKeepAliveTimeoutUs),
           mKeepAliveGeneration(0) {
         mNetLooper->setName("rtsp net");
@@ -577,6 +580,7 @@ struct MyHandler : public AHandler {
 
                         if (!track->mUsingInterleavedTCP) {
                             AString transport = response->mHeaders.valueAt(i);
+                            mTransport.push(transport);
 
                             // We are going to continue even if we were
                             // unable to poke a hole into the firewall...
@@ -945,6 +949,15 @@ struct MyHandler : public AHandler {
 
                 if (result == OK) {
                     mPaused = true;
+                    (new AMessage('poke', id()))->post(kNatRefreshTimeousUs);
+                }
+                break;
+            }
+
+            case 'poke':
+            {
+                if (mPaused) {
+                    mPokeHole = true;
                 }
                 break;
             }
@@ -955,6 +968,23 @@ struct MyHandler : public AHandler {
                     LOGW("Session not paused...");
                     break;
                 }
+                if (mPokeHole) {
+                    ALOGI("poke a hole after long time pause ");
+                    mPokeHole = false;
+                    size_t trackIndex = 0;
+                    for(size_t i=0; i < mTracks.size(); i++) {
+                        TrackInfo *track = &mTracks.editItemAt(i);
+                        if (!track->mUsingInterleavedTCP) {
+                            AString transport = mTransport.editItemAt(trackIndex);
+                            ++trackIndex;
+
+                            pokeAHole(
+                                    track->mRTPSocket,
+                                    track->mRTCPSocket,
+                                    transport);
+                        }
+                    }
+                }
 
                 mPaused = false;
                 AString request = "PLAY ";
@@ -1405,10 +1435,12 @@ private:
     bool mSeekable;
     bool mPlayRequestSent;
     bool mPaused;
+    bool mPokeHole;
     int64_t mKeepAliveTimeoutUs;
     int32_t mKeepAliveGeneration;
 
     Vector<TrackInfo> mTracks;
+    Vector<AString> mTransport;
 
     void setupTrack(size_t index) {
         sp<APacketSource> source =
-- 
1.7.4.1

