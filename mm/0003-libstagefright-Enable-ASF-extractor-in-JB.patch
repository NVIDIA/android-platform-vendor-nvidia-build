From 731a29685c56a66207d96c368ed1ae669a43ab3c Mon Sep 17 00:00:00 2001
From: aarti jadhav-gaikwad <agaikwad@nvidia.com>
Date: Thu, 24 May 2012 16:42:44 +0530
Subject: [PATCH 03/40] libstagefright : Enable ASF extractor in JB

Enabled ASF extractor and corrosponding
decoders (vc1, wma) in framework

Bug 991874

Change-Id: I4ba848bfb619b91fe457dd8819a22161725bc587
Reviewed-on: http://git-psac/r/224
Reviewed-by: Lokesh Pathak <lpathak@nvidia.com>
Tested-by: Lokesh Pathak <lpathak@nvidia.com>
---
 include/media/stagefright/MediaDebug.h             |   36 ++
 include/media/stagefright/MediaDefs.h              |    3 +
 include/media/stagefright/MetaData.h               |    3 +
 include/media/stagefright/NvParserHalDefines.h     |   59 +++
 media/libstagefright/ASFExtractor.cpp              |  432 ++++++++++++++++++++
 media/libstagefright/Android.mk                    |    2 +
 media/libstagefright/DataSource.cpp                |    2 +
 media/libstagefright/MediaDefs.cpp                 |    3 +
 media/libstagefright/MediaExtractor.cpp            |    3 +
 media/libstagefright/OMXCodec.cpp                  |   14 +-
 media/libstagefright/StagefrightMediaScanner.cpp   |    2 +-
 .../StagefrightMetadataRetriever.cpp               |   30 ++
 media/libstagefright/include/ASFExtractor.h        |   99 +++++
 13 files changed, 686 insertions(+), 2 deletions(-)
 create mode 100644 include/media/stagefright/MediaDebug.h
 create mode 100644 include/media/stagefright/NvParserHalDefines.h
 create mode 100644 media/libstagefright/ASFExtractor.cpp
 create mode 100644 media/libstagefright/include/ASFExtractor.h

diff --git a/include/media/stagefright/MediaDebug.h b/include/media/stagefright/MediaDebug.h
new file mode 100644
index 0000000..2ca9667
--- /dev/null
+++ b/include/media/stagefright/MediaDebug.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_DEBUG_H_
+
+#define MEDIA_DEBUG_H_
+
+#include <cutils/log.h>
+
+#define LITERAL_TO_STRING_INTERNAL(x)    #x
+#define LITERAL_TO_STRING(x) LITERAL_TO_STRING_INTERNAL(x)
+
+#define CHECK_EQ(x,y)                                                   \
+    LOG_ALWAYS_FATAL_IF(                                                \
+            (x) != (y),                                                 \
+            __FILE__ ":" LITERAL_TO_STRING(__LINE__) " " #x " != " #y)
+
+#define CHECK(x)                                                        \
+    LOG_ALWAYS_FATAL_IF(                                                \
+            !(x),                                                       \
+            __FILE__ ":" LITERAL_TO_STRING(__LINE__) " " #x)
+
+#endif  // MEDIA_DEBUG_H_
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 457d5d7..8da639f 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -28,6 +28,7 @@ extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4;
 extern const char *MEDIA_MIMETYPE_VIDEO_H263;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
 
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
@@ -42,6 +43,7 @@ extern const char *MEDIA_MIMETYPE_AUDIO_G711_MLAW;
 extern const char *MEDIA_MIMETYPE_AUDIO_RAW;
 extern const char *MEDIA_MIMETYPE_AUDIO_FLAC;
 extern const char *MEDIA_MIMETYPE_AUDIO_AAC_ADTS;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA;
 
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG4;
 extern const char *MEDIA_MIMETYPE_CONTAINER_WAV;
@@ -52,6 +54,7 @@ extern const char *MEDIA_MIMETYPE_CONTAINER_AVI;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS;
 
 extern const char *MEDIA_MIMETYPE_CONTAINER_WVM;
+extern const char *MEDIA_MIMETYPE_CONTAINER_ASF;
 
 extern const char *MEDIA_MIMETYPE_TEXT_3GPP;
 extern const char *MEDIA_MIMETYPE_TEXT_SUBRIP;
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index e91904c..8e1361f 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -74,6 +74,7 @@ enum {
     kKeyIsDRM             = 'idrm',  // int32_t (bool)
     kKeyEncoderDelay      = 'encd',  // int32_t (frames)
     kKeyEncoderPadding    = 'encp',  // int32_t (frames)
+    kKeyDecoderFlags      = 'dcfl',
 
     kKeyAlbum             = 'albu',  // cstring
     kKeyArtist            = 'arti',  // cstring
@@ -155,12 +156,14 @@ enum {
     kKeyCryptoKey         = 'cryK',  // uint8_t[16]
     kKeyCryptoIV          = 'cryI',  // uint8_t[16]
     kKeyCryptoMode        = 'cryM',  // int32_t
+    kKeyHeader            = 'hder', //// represents header
 };
 
 enum {
     kTypeESDS        = 'esds',
     kTypeAVCC        = 'avcc',
     kTypeD263        = 'd263',
+    kTypeHeader      = 'hder',
 };
 
 class MetaData : public RefBase {
diff --git a/include/media/stagefright/NvParserHalDefines.h b/include/media/stagefright/NvParserHalDefines.h
new file mode 100644
index 0000000..397e691
--- /dev/null
+++ b/include/media/stagefright/NvParserHalDefines.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NVPARSER_HAL_DEFINES_H_
+
+#define NVPARSER_HAL_DEFINES_H_
+
+#include <utils/Errors.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaSource.h>
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+namespace android {
+
+typedef status_t (*NvParserHalCreateFunc)(char*,void** pNvParserHalHandle);
+typedef status_t (*NvParserHalDestroyFunc)(void* NvParserHalHandle);
+typedef size_t (*NvParserHalGetStreamCountFunc)(void* NvParserHalHandle);
+typedef status_t (*NvParserHalGetMetaDataFunc) (void* asfParserHalHandle, sp<MetaData> mFileMetaData);
+typedef status_t (*NvParserHalGetTrackMetaDataFunc) (void* asfParserHalHandle, int32_t streamIndex, bool setThumbnailTime, sp<MetaData> mTrackMetaData);
+typedef status_t (*NvParserHalSetTrackHeaderFunc) (void* asfParserHalHandle, int32_t streamIndex, sp<MetaData> meta);
+typedef status_t (*NvParserHalReadFunc) (void* asfParserHalHandle, int32_t streamIndex, MediaBuffer* mBuffer, const MediaSource::ReadOptions* options);
+typedef bool (*NvParserHalIsSeekableFunc) (void* NvParserHalHandle);
+
+
+typedef struct {
+    NvParserHalCreateFunc nvParserHalCreateFunc;
+    NvParserHalDestroyFunc nvParserHalDestroyFunc;
+    NvParserHalGetStreamCountFunc nvParserHalGetStreamCountFunc;
+    NvParserHalGetMetaDataFunc nvParserHalGetMetaDataFunc;
+    NvParserHalGetTrackMetaDataFunc nvParserHalGetTrackMetaDataFunc;
+    NvParserHalSetTrackHeaderFunc nvParserHalSetTrackHeaderFunc;
+    NvParserHalReadFunc nvParserHalReadFunc;
+    NvParserHalIsSeekableFunc nvParserHalIsSeekableFunc;
+}NvParseHalImplementation;
+
+} // namespace android
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif //#ifndef  NVPARSER_HAL_DEFINES_H_
diff --git a/media/libstagefright/ASFExtractor.cpp b/media/libstagefright/ASFExtractor.cpp
new file mode 100644
index 0000000..2264f7f
--- /dev/null
+++ b/media/libstagefright/ASFExtractor.cpp
@@ -0,0 +1,432 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "ASFExtractor"
+#include <utils/Log.h>
+#include "include/ASFExtractor.h"
+#include <stdlib.h>
+#include <string.h>
+#include <media/stagefright/DataSource.h>
+#include <OMX_Types.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+#include "include/avc_utils.h"
+#include <dlfcn.h>
+
+namespace android {
+
+class ASFSource : public MediaSource{
+public:
+    // Caller retains ownership of both "dataSource" and "Parser Handle".
+    ASFSource(const sp<MetaData> &format,
+        const sp<DataSource> &dataSource,
+        uint32_t mTrackCount, size_t &index,
+        ASFExtractorData *extractor, NvParseHalImplementation nvAsfParseHalImpl,
+        void* NvAsfParserHalHandle);
+
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual sp<MetaData> getFormat();
+    virtual void InitSource(size_t& index, ASFExtractorData *Extractor);
+    virtual status_t read(
+        MediaBuffer **buffer, const ReadOptions *options = NULL);
+
+protected:
+    virtual ~ASFSource();
+
+private:
+    sp<MetaData> mFormat;
+    sp<DataSource> mDataSource;
+    ASFExtractorData *m_hExtractor;
+    bool mStarted;
+    size_t mTrackIndex;
+    MediaBufferGroup *mGroup;
+    MediaBuffer *mBuffer;
+    uint32_t mTrackCount;
+    NvParseHalImplementation nvAsfParseHalImpl;
+    void* NvAsfParserHalHandle;
+
+    ASFSource(const ASFSource &);
+    ASFSource &operator=(const ASFSource &);
+};
+
+/**********************************************************************************************************************/
+ASFExtractor :: ASFExtractor(const sp<DataSource> &source)
+        : mDataSource(source),
+        Extractor(NULL),
+        mHaveMetadata(false),
+        mDuration(0),
+        mFlags(0),
+        NvAsfParserHalLibHandle(NULL),
+        mFileMetaData(new MetaData) {
+
+    const char* error;
+
+    memset(&mTracks,0,sizeof(Track)*MAX_INPUT_STREAMS);
+
+    LOGV("ASFExtractor::ASFExtractor");
+    if(NvAsfParserHalLibHandle == NULL) {
+        // Clear the old errors, no need to handle return for clearing
+        dlerror();
+        NvAsfParserHalLibHandle = dlopen("libnvasfparserhal.so", RTLD_NOW);
+        if(NvAsfParserHalLibHandle == NULL) {
+            LOGE("Failed to libnvasfarserhal.so with error %s\n",dlerror());
+            return;
+        }
+    }
+
+    typedef void *(*GetInstanceFunc)(NvParseHalImplementation *);
+    // Clear the old errors, no need to handle return for clearing
+    dlerror();
+    GetInstanceFunc getInstanceFunc =
+        (GetInstanceFunc) dlsym(NvAsfParserHalLibHandle, "NvAsfParserHal_GetInstanceFunc");
+
+    error = dlerror();
+    if(error != NULL) {
+        LOGE("Failed to locate NvAsfParserHal_GetInstanceFunc in libnvasfarserhal.so ");
+        return;
+    } else {
+        getInstanceFunc(&nvAsfParseHalImpl);
+    }
+}
+
+/**********************************************************************************************************************/
+ASFExtractor::~ASFExtractor() {
+    status_t err = OK;
+    LOGV("ASFExtractor::~ASFExtractor");
+
+    if((mFlags & IS_INITIALIZED) && !(mFlags & HAS_SHARED_HAL)) {
+        err = nvAsfParseHalImpl.nvParserHalDestroyFunc(NvAsfParserHalHandle);
+        NvAsfParserHalHandle = NULL;
+        CHECK_EQ(err,OK);
+        delete Extractor;
+        Extractor = NULL;
+    }
+}
+
+/**********************************************************************************************************************/
+bool ASFExtractor::initParser() {
+    status_t err = OK;
+    char pFilename[128];
+
+    if(mFlags & IS_INITIALIZED)
+        return true;
+
+    if(NvAsfParserHalLibHandle == NULL) {
+        LOGE("Error in ASFExtractor::initParser");
+        return false;
+    }
+
+    LOGV("In ASFExtractor::initParser");
+    Extractor = new ASFExtractorData;
+    memset(Extractor,0,sizeof(ASFExtractorData));
+
+    sprintf((char *)pFilename,"stagefright://%x",(mDataSource.get()));
+    err = nvAsfParseHalImpl.nvParserHalCreateFunc(pFilename,&NvAsfParserHalHandle);
+    if(err != OK) {
+        LOGE("Error in ASFExtractor::initParser");
+        return false;
+    }
+
+    // Get number track count
+    mTrackCount = nvAsfParseHalImpl.nvParserHalGetStreamCountFunc(NvAsfParserHalHandle);
+    mFlags |= HAS_TRACK_COUNT | IS_INITIALIZED;
+
+    return true;
+}
+
+/**********************************************************************************************************************/
+sp<MetaData> ASFExtractor::getMetaData() {
+    status_t err = OK;
+
+    LOGV("ASFExtractor::getMetaData ");
+
+    if(!(mFlags & IS_INITIALIZED)) {
+        if(!initParser()) {
+            return mFileMetaData;
+        }
+    }
+    if(mFlags & HAS_FILE_METADATA) {
+        return mFileMetaData;
+    }
+
+    err = nvAsfParseHalImpl.nvParserHalGetMetaDataFunc(NvAsfParserHalHandle,mFileMetaData);
+    if(err == OK) {
+        mFlags |= HAS_FILE_METADATA;
+    }
+
+    return mFileMetaData;
+}
+
+/**********************************************************************************************************************/
+size_t ASFExtractor::countTracks() {
+    status_t err = OK;
+    LOGV("ASFExtractor::countTracks ");
+
+    if(!(mFlags & IS_INITIALIZED)) {
+        if(!initParser()) {
+            err = UNKNOWN_ERROR;
+            return 0;
+        }
+    }
+    if(!(mFlags & HAS_TRACK_COUNT)) {
+        mTrackCount = nvAsfParseHalImpl.nvParserHalGetStreamCountFunc(NvAsfParserHalHandle);
+        mFlags |= HAS_TRACK_COUNT;
+    }
+
+    return mTrackCount;
+}
+
+/**********************************************************************************************************************/
+sp<MetaData> ASFExtractor::getTrackMetaData(
+    size_t index, uint32_t flags) {
+    status_t err = OK;
+
+    if((mTracks[index].has_meta_data == true) && (!(flags & kIncludeExtensiveMetaData))) {
+        return mTracks[index].meta;
+    }
+
+    LOGV("ASFExtractor::getTrackMetaData ");
+
+    if(!(flags & kIncludeExtensiveMetaData)) {
+        mTracks[index].meta = new MetaData;
+        mTracks[index].timescale = 0;
+        mTracks[index].includes_expensive_metadata = false;
+    } else {
+        mTracks[index].includes_expensive_metadata = true;
+    }
+
+    err = nvAsfParseHalImpl.nvParserHalGetTrackMetaDataFunc(NvAsfParserHalHandle, index, (flags & kIncludeExtensiveMetaData), mTracks[index].meta);
+    if(err == OK) {
+        mTracks[index].has_meta_data = true;
+        return  mTracks[index].meta;
+    } else {
+        return NULL;
+    }
+}
+
+/**********************************************************************************************************************/
+sp<MediaSource> ASFExtractor::getTrack(size_t index) {
+
+    Track  track = mTracks[index];
+    mFlags |= HAS_SHARED_HAL;
+    LOGV("Returning Track index %d",index);
+
+    return new ASFSource(
+        track.meta, mDataSource, mTrackCount,index,Extractor,nvAsfParseHalImpl,NvAsfParserHalHandle);
+}
+
+/**********************************************************************************************************************
+**********************************************************************************************************************/
+ASFSource::ASFSource(
+        const sp<MetaData> &format,
+        const sp<DataSource> &dataSource,
+        uint32_t mTrackCount,size_t &index,
+        ASFExtractorData *extractor,
+        NvParseHalImplementation nvAsfParseHalImpl,
+        void* NvAsfParserHalHandle)
+        : mFormat(format),
+        mDataSource(dataSource),
+        mStarted(false),
+        mTrackIndex(index),
+        mGroup(NULL),
+        mBuffer(NULL),
+        mTrackCount(mTrackCount),
+        nvAsfParseHalImpl(nvAsfParseHalImpl),
+        NvAsfParserHalHandle(NvAsfParserHalHandle) {
+
+    InitSource(mTrackIndex,extractor);
+    m_hExtractor->mSourceCreated++;
+}
+
+/**********************************************************************************************************************/
+void ASFSource::InitSource(size_t &index, ASFExtractorData *Extractor) {
+    status_t err = OK;
+    char pFilename[128];
+
+    LOGV("In ASFSource::InitSource");
+    if(Extractor == NULL) {
+        m_hExtractor = new ASFExtractorData;
+        memset(m_hExtractor,0,sizeof(ASFExtractorData));
+        sprintf((char *)pFilename,"stagefright://%x",(mDataSource.get()));
+        err = nvAsfParseHalImpl.nvParserHalCreateFunc(pFilename,&NvAsfParserHalHandle);
+        if(err != OK) {
+            return;
+        }
+    } else {
+        m_hExtractor = Extractor;
+        LOGV("Reusing ASF source %p",Extractor);
+    }
+
+    sp<MetaData> meta = mFormat;
+    err = nvAsfParseHalImpl.nvParserHalSetTrackHeaderFunc(NvAsfParserHalHandle,index,meta);
+    if(err != OK) {
+        return;
+    }
+}
+
+/**********************************************************************************************************************/
+ASFSource::~ASFSource() {
+    LOGV("ASFSource::~ASFSource() ");
+    if(mStarted) {
+        stop();
+    }
+    if (m_hExtractor) {
+        m_hExtractor->mSourceCreated--;
+        if (m_hExtractor->mSourceCreated == 0 && NvAsfParserHalHandle) {
+            LOGV("%s[%d], destrying parser HAL",__FUNCTION__,__LINE__);
+            nvAsfParseHalImpl.nvParserHalDestroyFunc(NvAsfParserHalHandle);
+            NvAsfParserHalHandle = NULL;
+
+            //Free extractor memory
+            delete m_hExtractor;
+            m_hExtractor = NULL;
+        }
+    }
+}
+
+/**********************************************************************************************************************/
+status_t ASFSource::start(MetaData *params) {
+    Mutex::Autolock autoLock(m_hExtractor->mMutex);
+    status_t err = OK;
+    int32_t max_size;
+    LOGV("enterd ASFSource start mTrackIndex %d ", mTrackIndex);
+    CHECK(!mStarted);
+
+    if(m_hExtractor == NULL) {
+        LOGV("ASFSource Probably Restarted !!!!");
+        InitSource(mTrackIndex, NULL);
+    }
+    // Check Once again
+    if(m_hExtractor == NULL) {
+        LOGE("Serious Allocation Error");
+        return UNKNOWN_ERROR;
+    }
+
+    mGroup = new MediaBufferGroup;
+    CHECK(mFormat->findInt32(kKeyMaxInputSize, &max_size));
+    mGroup->add_buffer(new MediaBuffer(max_size));
+
+    mStarted = true;
+    return OK;
+}
+
+/**********************************************************************************************************************/
+status_t ASFSource::stop() {
+    Mutex::Autolock autoLock(m_hExtractor->mMutex);
+
+    LOGV("ASFSource Stop--------");
+    status_t err = OK;
+    mStarted = false;
+
+   if(mBuffer != NULL) {
+        mBuffer->release();
+        mBuffer = NULL;
+    }
+
+    delete mGroup;
+    mGroup = NULL;
+    return err;
+}
+
+/**********************************************************************************************************************/
+sp<MetaData> ASFSource::getFormat() {
+    return mFormat;
+}
+
+/**********************************************************************************************************************/
+status_t ASFSource::read(
+    MediaBuffer **out, const ReadOptions *options) {
+
+    Mutex::Autolock autoLock(m_hExtractor->mMutex);
+    status_t err = OK;
+    int32_t decoderFlags = 0;
+    CHECK(mStarted);
+
+    *out = NULL;
+
+    err = mGroup->acquire_buffer(&mBuffer);
+    if (err != OK) {
+        CHECK_EQ(mBuffer, NULL);
+        return err;
+    }
+
+    err = nvAsfParseHalImpl.nvParserHalReadFunc(NvAsfParserHalHandle,mTrackIndex, mBuffer, options);
+    if(err != OK) {
+        goto cleanup;
+    }
+
+    // Check if buffer contains codec config data
+    mBuffer->meta_data()->findInt32(kKeyDecoderFlags, &decoderFlags);
+    if(decoderFlags & OMX_BUFFERFLAG_CODECCONFIG) {
+        sp<MetaData> meta = mFormat;
+        uint8_t * temp = (uint8_t *)mBuffer->data();
+        meta->setData(kKeyHeader, kTypeHeader, temp, mBuffer->range_length());
+        /*Do not pass options this time as seek is already done in previous function call */
+        err = nvAsfParseHalImpl.nvParserHalReadFunc(NvAsfParserHalHandle,mTrackIndex, mBuffer, NULL);
+        if(err != OK) {
+            goto cleanup;
+        }
+    }
+    if(mBuffer->range_length() == 0) {
+        LOGV("Read is returing zero sized buffer ");
+    }
+cleanup:
+    if(err == OK) {
+        *out = mBuffer;
+    } else {
+        *out = NULL;
+        if(mBuffer) {
+            mBuffer->release();
+        }
+    }
+
+    mBuffer = NULL;
+    return err;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////
+
+bool SniffASF(const sp<DataSource> &source, String8 *mimeType,
+        float *confidence, sp<AMessage> *meta) {
+
+    uint8_t header[16];
+
+    ssize_t n = source->readAt(0, header, sizeof(header));
+    if(n < (ssize_t)sizeof(header)) {
+        return false;
+    }
+
+    if(!memcmp(header, ASF_HEADER_GUID, 16)) {
+        *mimeType = MEDIA_MIMETYPE_CONTAINER_ASF;
+        *confidence = 1.0;
+        LOGV ("asf is identified ####");
+        return true;
+    }
+    return false;
+}
+
+}  // namespace android
+
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index faa0f31..28f2a5b 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -8,6 +8,7 @@ LOCAL_SRC_FILES:=                         \
         AACExtractor.cpp                  \
         AACWriter.cpp                     \
         AMRExtractor.cpp                  \
+        ASFExtractor.cpp                  \
         AMRWriter.cpp                     \
         AudioPlayer.cpp                   \
         AudioSource.cpp                   \
@@ -64,6 +65,7 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/external/flac/include \
         $(TOP)/external/tremolo \
         $(TOP)/external/openssl/include \
+        $(TEGRA_TOP)/multimedia-partner/openmax/include/openmax/il
 
 LOCAL_SHARED_LIBRARIES := \
         libbinder \
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 9d0eea2..8241723 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -33,6 +33,7 @@
 #include "include/OggExtractor.h"
 #include "include/WAVExtractor.h"
 #include "include/WVMExtractor.h"
+#include "include/ASFExtractor.h"
 
 #include "matroska/MatroskaExtractor.h"
 
@@ -128,6 +129,7 @@ void DataSource::RegisterDefaultSniffers() {
             && (!strcmp(value, "1") || !strcasecmp(value, "true"))) {
         RegisterSniffer(SniffDRM);
     }
+    RegisterSniffer(SniffASF);
 }
 
 // static
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index e7b5903..d64ca23 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -26,6 +26,7 @@ const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
+const char *MEDIA_MIMETYPE_VIDEO_WMV = "video/x-ms-wmv";
 
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";
@@ -40,6 +41,7 @@ const char *MEDIA_MIMETYPE_AUDIO_G711_MLAW = "audio/g711-mlaw";
 const char *MEDIA_MIMETYPE_AUDIO_RAW = "audio/raw";
 const char *MEDIA_MIMETYPE_AUDIO_FLAC = "audio/flac";
 const char *MEDIA_MIMETYPE_AUDIO_AAC_ADTS = "audio/aac-adts";
+const char *MEDIA_MIMETYPE_AUDIO_WMA = "audio/x-ms-wma";
 
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG4 = "video/mp4";
 const char *MEDIA_MIMETYPE_CONTAINER_WAV = "audio/x-wav";
@@ -50,6 +52,7 @@ const char *MEDIA_MIMETYPE_CONTAINER_AVI = "video/avi";
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS = "video/mp2p";
 
 const char *MEDIA_MIMETYPE_CONTAINER_WVM = "video/wvm";
+const char *MEDIA_MIMETYPE_CONTAINER_ASF = "video/x-ms-asf";
 
 const char *MEDIA_MIMETYPE_TEXT_3GPP = "text/3gpp-tt";
 const char *MEDIA_MIMETYPE_TEXT_SUBRIP = "application/x-subrip";
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index b18c916..19f95bb 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -19,6 +19,7 @@
 #include <utils/Log.h>
 
 #include "include/AMRExtractor.h"
+#include "include/ASFExtractor.h"
 #include "include/MP3Extractor.h"
 #include "include/MPEG4Extractor.h"
 #include "include/FragmentedMP4Extractor.h"
@@ -122,6 +123,8 @@ sp<MediaExtractor> MediaExtractor::Create(
         ret = new AACExtractor(source, meta);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) {
         ret = new MPEG2PSExtractor(source);
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_ASF)) {
+        ret = new ASFExtractor(source);
     }
 
     if (ret != NULL) {
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 88dcb2f..2fe742c 100755
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -462,6 +462,11 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         uint32_t type;
         const void *data;
         size_t size;
+
+        if (meta->findData(kTypeHeader, &type, &data, &size)) {
+            LOGV ("Kkey header found .. SEND HEADER.");
+            addCodecSpecificData(data,size );
+        }
         if (meta->findData(kKeyESDS, &type, &data, &size)) {
             ESDS esds((const char *)data, size);
             CHECK_EQ(esds.InitCheck(), (status_t)OK);
@@ -1188,6 +1193,8 @@ status_t OMXCodec::setVideoOutputFormat(
         compressionFormat = OMX_VIDEO_CodingVPX;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG2;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
+        compressionFormat = OMX_VIDEO_CodingWMV;
     } else {
         ALOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -3013,7 +3020,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     size_t offset = 0;
     int32_t n = 0;
-
+    int32_t srcflags = 0;
 
     for (;;) {
         MediaBuffer *srcBuffer;
@@ -3109,6 +3116,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         int64_t lastBufferTimeUs;
         CHECK(srcBuffer->meta_data()->findInt64(kKeyTime, &lastBufferTimeUs));
         CHECK(lastBufferTimeUs >= 0);
+        srcBuffer->meta_data()->findInt32(kKeyDecoderFlags, &srcflags);
         if (mIsEncoder && mIsVideo) {
             mDecodingTimeList.push_back(lastBufferTimeUs);
         }
@@ -3160,6 +3168,10 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
     }
 
     OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;
+    if(srcflags)
+    {
+        flags |= srcflags;
+    }
 
     if (signalEOS) {
         flags |= OMX_BUFFERFLAG_EOS;
diff --git a/media/libstagefright/StagefrightMediaScanner.cpp b/media/libstagefright/StagefrightMediaScanner.cpp
index b7cf96e..559a9d2 100644
--- a/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/media/libstagefright/StagefrightMediaScanner.cpp
@@ -42,7 +42,7 @@ static bool FileHasAcceptableExtension(const char *extension) {
         ".mpeg", ".ogg", ".mid", ".smf", ".imy", ".wma", ".aac",
         ".wav", ".amr", ".midi", ".xmf", ".rtttl", ".rtx", ".ota",
         ".mkv", ".mka", ".webm", ".ts", ".fl", ".flac", ".mxmf",
-        ".avi", ".mpeg", ".mpg"
+        ".avi", ".mpeg", ".mpg", ".asf"
     };
     static const size_t kNumValidExtensions =
         sizeof(kValidExtensions) / sizeof(kValidExtensions[0]);
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index a2f3f13..4e23b94 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -594,8 +594,38 @@ void StagefrightMetadataRetriever::parseMetaData() {
                         METADATA_KEY_MIMETYPE, String8("audio/x-matroska"));
             }
         }
+        else if (!strcasecmp(fileMIME, "video/avc") )
+            //This condition will be true if ASF file contains only h264.
+            mMetaData.add(
+                    METADATA_KEY_MIMETYPE, String8("video/x-ms-asf"));
+        else if (!strcasecmp(fileMIME, "audio/mp4a-latm"))
+            //This condition will be true if ASF file contains only aac.
+            mMetaData.add(
+                    METADATA_KEY_MIMETYPE, String8("audio/aac"));
+    } else {
+        const char *fileMIME;
+        CHECK(meta->findCString(kKeyMIMEType, &fileMIME));
+        if (!strcasecmp(fileMIME, "audio/x-ms-wma")) {
+            for (size_t i = 0; i < numTracks; ++i) {
+                sp<MetaData> trackMeta = mExtractor->getTrackMetaData(i);
+                const char *trackMIME;
+                CHECK(trackMeta->findCString(kKeyMIMEType, &trackMIME));
+
+                if (!strncasecmp("video/", trackMIME, 6)) {
+                    // When fileMIME is returned as audio, setting fileMIME
+                    // to video for video + audio files
+                    mMetaData.add(
+                            METADATA_KEY_MIMETYPE, String8("video/x-ms-wmv"));
+                }
+            }
+        }
+        else if (!strcasecmp(fileMIME, "video/avc") || !strcasecmp(fileMIME, "audio/mp4a-latm"))
+            //This condition will be true if ASF file contains h264 or aac.
+            mMetaData.add(
+                    METADATA_KEY_MIMETYPE, String8("video/x-ms-asf"));
     }
 
+
     // To check whether the media file is drm-protected
     if (mExtractor->getDrmFlag()) {
         mMetaData.add(METADATA_KEY_IS_DRM, String8("1"));
diff --git a/media/libstagefright/include/ASFExtractor.h b/media/libstagefright/include/ASFExtractor.h
new file mode 100644
index 0000000..c6b8c8d
--- /dev/null
+++ b/media/libstagefright/include/ASFExtractor.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ASF_EXTRACTOR_H_
+
+#define ASF_EXTRACTOR_H_
+
+#include <utils/Errors.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/NvParserHalDefines.h>
+#include <OMX_Core.h>
+#include <NVOMX_IndexExtensions.h>
+#include <utils/List.h>
+#include <utils/threads.h>
+
+#define COMMON_MAX_INPUT_BUFFER_SIZE       64 * 1024
+#define MAX_INPUT_STREAMS 2
+
+static uint8_t ASF_HEADER_GUID[16] =
+    { 0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C };
+
+namespace android {
+
+struct AMessage;
+class DataSource;
+class String8;
+
+typedef struct
+{
+    uint32_t mSourceCreated;
+    Mutex mMutex;
+}ASFExtractorData;
+
+class ASFExtractor : public MediaExtractor {
+public:
+    // Extractor assumes ownership of "source".
+    ASFExtractor(const sp<DataSource> &source);
+    virtual size_t countTracks();
+    virtual sp<MediaSource> getTrack(size_t index);
+    virtual sp<MetaData> getTrackMetaData(size_t index, uint32_t flags);
+    virtual sp<MetaData> getMetaData();
+    virtual bool initParser();
+
+protected:
+    virtual ~ASFExtractor();
+
+private:
+    enum {
+        IS_INITIALIZED              = 1,
+        HAS_TRACK_COUNT             = 2,
+        HAS_FILE_METADATA           = 4,
+        HAS_SHARED_HAL              = 8
+    };
+
+    struct Track {
+        sp<MetaData> meta;
+        uint32_t timescale;
+        bool includes_expensive_metadata;
+        bool has_meta_data;
+    };
+
+    Track mTracks[MAX_INPUT_STREAMS];
+    sp<MetaData> mTrackMeta;
+    sp<DataSource> mDataSource;
+    ASFExtractorData *Extractor;
+    bool mHaveMetadata;
+    uint32_t mTrackCount;
+    uint32_t mDuration;
+    uint32_t mFlags;
+    void* NvAsfParserHalLibHandle;
+    void* NvAsfParserHalHandle;
+    sp<MetaData> mFileMetaData;
+
+    NvParseHalImplementation nvAsfParseHalImpl;
+    ASFExtractor(const ASFExtractor &);
+    ASFExtractor &operator=(const ASFExtractor &);
+};
+
+bool SniffASF(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+        sp<AMessage> *);
+
+}  // namespace android
+
+#endif  // ASF_EXTRACTOR_H_
+
-- 
1.7.1

