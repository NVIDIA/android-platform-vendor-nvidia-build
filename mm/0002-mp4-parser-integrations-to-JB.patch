From 6f303948c2652614bcf05c4fce43eea7ff406acf Mon Sep 17 00:00:00 2001
From: manikanta kanamarlapudi <manikak@nvidia.com>
Date: Fri, 1 Jun 2012 17:07:47 +0530
Subject: [PATCH 02/40] mp4 parser integrations to JB

bug 991874

Change-Id: I9091fe15d43f0cfded5f6190ed0c59d20acfa02e
Reviewed-on: http://git-psac/r/229
Reviewed-by: Dhiraj Nadgouda <dnadgouda@nvidia.com>
Reviewed-by: Yogesh Solanke <ysolanke@nvidia.com>
Reviewed-by: Parag Mehendale <pmehendale@nvidia.com>
Tested-by: Manikanta Kanamarlapudi <manikak@nvidia.com>
Reviewed-by: Zhijun He <zhhe@nvidia.com>
---
 media/libstagefright/AwesomePlayer.cpp        |    4 +
 media/libstagefright/MPEG4Extractor.cpp       |  273 ++++++++++++++++++++++---
 media/libstagefright/SampleIterator.cpp       |    7 +-
 media/libstagefright/SampleTable.cpp          |   25 ++-
 media/libstagefright/include/MPEG4Extractor.h |    5 +
 5 files changed, 281 insertions(+), 33 deletions(-)

diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 685e676..d49ded8 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -1306,6 +1306,10 @@ status_t AwesomePlayer::seekTo(int64_t timeUs) {
 }
 
 status_t AwesomePlayer::seekTo_l(int64_t timeUs) {
+    if (timeUs == ((mDurationUs/1000)*1000)) {
+        timeUs = mDurationUs;
+    }
+
     if (mFlags & CACHE_UNDERRUN) {
         modifyFlags(CACHE_UNDERRUN, CLEAR);
         play_l();
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index dc8e4a3..4d77a27 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -49,7 +49,8 @@ public:
     MPEG4Source(const sp<MetaData> &format,
                 const sp<DataSource> &dataSource,
                 int32_t timeScale,
-                const sp<SampleTable> &sampleTable);
+                const sp<SampleTable> &sampleTable,
+                int64_t streamDurationUs);
 
     virtual status_t start(MetaData *params = NULL);
     virtual status_t stop();
@@ -68,6 +69,7 @@ private:
     sp<MetaData> mFormat;
     sp<DataSource> mDataSource;
     int32_t mTimescale;
+    int64_t mFilesize;
     sp<SampleTable> mSampleTable;
     uint32_t mCurrentSampleIndex;
 
@@ -84,6 +86,8 @@ private:
 
     uint8_t *mSrcBuffer;
 
+    int64_t mStreamDurationUs;
+
     size_t parseNALSize(const uint8_t *data) const;
 
     MPEG4Source(const MPEG4Source &);
@@ -271,7 +275,9 @@ MPEG4Extractor::MPEG4Extractor(const sp<DataSource> &source)
       mLastTrack(NULL),
       mFileMetaData(new MetaData),
       mFirstSINF(NULL),
-      mIsDrm(false) {
+      mIsDrm(false),
+      mStreamDurationUs(0),
+      m_qtmode(0) {
 }
 
 MPEG4Extractor::~MPEG4Extractor() {
@@ -671,7 +677,36 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         return OK;
     }
+    //if ftyp atom .. set up m_qtmode mode
+    if(chunk_type == FOURCC('f','t','y','p')) {
+        uint32_t typval[1];
+        if (mDataSource->readAt(data_offset, typval, 4) < 4) {
+            return ERROR_IO;
+        }
+        //data_offset += 4;
+        uint32_t file_type = ntohl(typval[0]);
+
+        if(file_type == FOURCC('q','t',' ',' ')) {
+            m_qtmode = 1;
+            LOGI(" QT MODE DECIDED \n");
+        }
+        else {
+            LOGI(" NON-QT MODE DECIDED \n");
+        }
+    }
 
+    if(*offset == 0 && chunk_type == FOURCC('m','o','o','v'))
+    {
+        m_qtmode = 1;
+        LOGI(" QT MODE DECIDED \n");
+    }
+
+    if(chunk_type == 0x00000000) {
+        if(mLastTrack)
+            mLastTrack->TerminatorAtomReached = true;
+        *offset += chunk_size;
+           return OK;
+    }
     switch(chunk_type) {
         case FOURCC('m', 'o', 'o', 'v'):
         case FOURCC('t', 'r', 'a', 'k'):
@@ -716,6 +751,8 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 }
                 mLastTrack = track;
 
+                mLastTrack->esds_success = false;
+                mLastTrack->TerminatorAtomReached = false;
                 track->meta = new MetaData;
                 track->includes_expensive_metadata = false;
                 track->skipTrack = false;
@@ -726,9 +763,16 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             off64_t stop_offset = *offset + chunk_size;
             *offset = data_offset;
             while (*offset < stop_offset) {
-                status_t err = parseChunk(offset, depth + 1);
-                if (err != OK) {
-                    return err;
+                if(chunk_type == FOURCC('u','d','t','a')) {
+                    if(stop_offset - *offset < 8) {
+                        *offset = stop_offset;
+                    }
+                }
+                if(*offset < stop_offset) {
+                    status_t err = parseChunk(offset, depth + 1);
+                    if (err != OK) {
+                        return err;
+                    }
                 }
             }
 
@@ -832,8 +876,12 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 }
                 duration = ntohl(duration32);
             }
-            mLastTrack->meta->setInt64(
-                    kKeyDuration, (duration * 1000000) / mLastTrack->timescale);
+            duration = (duration * 1000000) / mLastTrack->timescale;
+            mLastTrack->meta->setInt64(kKeyDuration, duration);
+
+            if (duration > mStreamDurationUs) {
+                mStreamDurationUs = duration;
+            }
 
             uint8_t lang[2];
             off64_t lang_offset;
@@ -897,9 +945,8 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
                 if (strcasecmp(mime, MEDIA_MIMETYPE_TEXT_3GPP)) {
                     // For now we only support a single type of media per track.
-                    mLastTrack->skipTrack = true;
-                    *offset += chunk_size;
-                    break;
+                    // Get only single sample Descriptor table
+                    entry_count = 1;
                 }
             }
 
@@ -908,7 +955,15 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             for (uint32_t i = 0; i < entry_count; ++i) {
                 status_t err = parseChunk(offset, depth + 1);
                 if (err != OK) {
-                    return err;
+                    if(mLastTrack->esds_success == true && mLastTrack->TerminatorAtomReached == true) {
+                        *offset = stop_offset;
+                        return OK;
+                    }
+                } else {
+                    // For now we only support a single type of media per track
+                    // So returning OK after getting first sample descriptor
+                    *offset = stop_offset;
+                    return OK;
                 }
             }
 
@@ -922,6 +977,18 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('s', 'a', 'm', 'r'):
         case FOURCC('s', 'a', 'w', 'b'):
         {
+            if(m_qtmode){
+                if (mPath.size() >= 2&& mPath[mPath.size() - 2] == FOURCC('w', 'a', 'v', 'e')) {
+                    *offset += chunk_size;
+                    LOGI("(qtmode) its wave preb node.mp4a. so break here...\n");
+                    break;
+
+                }
+                else{
+                    LOGI("atoms_path: -1: %d -2:%d -3:%d \n", mPath[mPath.size()-1],mPath[mPath.size()-2],mPath[mPath.size()-3]);
+                }
+            }
+            //read sound media description - ver0, ver1....
             uint8_t buffer[8 + 20];
             if (chunk_data_size < (ssize_t)sizeof(buffer)) {
                 // Basic AudioSampleEntry size.
@@ -934,9 +1001,16 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             }
 
             uint16_t data_ref_index = U16_AT(&buffer[6]);
+            uint16_t version = U16_AT(&buffer[8]);
+            uint16_t rev_level = U16_AT(&buffer[10]);
+            uint32_t vendorid = U32_AT(&buffer[12]);
+            char vendorStr[5];
+            MakeFourCCString(vendorid, vendorStr);
             uint16_t num_channels = U16_AT(&buffer[16]);
 
             uint16_t sample_size = U16_AT(&buffer[18]);
+            //compression id - 16b - [20]
+            //pkt sz - 16b [22]
             uint32_t sample_rate = U32_AT(&buffer[24]) >> 16;
 
             if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB,
@@ -960,8 +1034,33 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);
             mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);
 
+            int extraread = 0;
+            if(m_qtmode) {
+                if(version == 1) {
+                    //skip 16 bytes as of now
+                    extraread = 16;
+                    uint8_t buffer1[16];
+                    if (mDataSource->readAt(data_offset+20, buffer1, sizeof(buffer1)) < (ssize_t)sizeof(buffer1)) {
+                        return ERROR_IO;
+                    }
+                    else {
+                        LOGI("qtmode/ver=1 , extradataread 16 \n");
+                    }
+                    //ASSERT(DECOMPRESSORID ==2) /// It follows frma,wave,esds,..etc variants of it... terminator atom!
+                }
+                else if (version == 2) {
+                    extraread = 36;
+                    uint8_t buffer12[36];
+                    if (mDataSource->readAt(data_offset+20, buffer12, sizeof(buffer12)) < (ssize_t)sizeof(buffer12)) {
+                        return ERROR_IO;
+                    }
+                    else {
+                        LOGI("qtmode/ver=2 , extradataread 36 \n");
+                    }
+                }
+            }
             off64_t stop_offset = *offset + chunk_size;
-            *offset = data_offset + sizeof(buffer);
+            *offset = data_offset + sizeof(buffer) + extraread;
             while (*offset < stop_offset) {
                 status_t err = parseChunk(offset, depth + 1);
                 if (err != OK) {
@@ -1015,9 +1114,14 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             off64_t stop_offset = *offset + chunk_size;
             *offset = data_offset + sizeof(buffer);
             while (*offset < stop_offset) {
-                status_t err = parseChunk(offset, depth + 1);
-                if (err != OK) {
-                    return err;
+                if(stop_offset - *offset < 8) {
+                    *offset = stop_offset;
+                }
+                else {
+                    status_t err = parseChunk(offset, depth + 1);
+                    if (err != OK) {
+                        return err;
+                    }
                 }
             }
 
@@ -1210,18 +1314,30 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
                 status_t err = updateAudioTrackInfoFromESDS_MPEG4Audio(
                         &buffer[4], chunk_data_size - 4);
 
+                // We dont support mp3 audio in mp4 container.But we should genrate
+                // the thumbnail and play video for such a stream,according to our policy.
+                // So,instead of returning an error,we just skip such audio track.
+
+                if (err == ERROR_UNSUPPORTED) {
+                    LOGE("Skipping unsupported audio track.");
+                    mLastTrack->skipTrack = true;
+                    *offset += chunk_size;
+                    break;
+                }
+
                 if (err != OK) {
                     return err;
                 }
             }
 
             *offset += chunk_size;
+            mLastTrack->esds_success = true;
             break;
         }
 
         case FOURCC('a', 'v', 'c', 'C'):
         {
-            char buffer[256];
+            char buffer[512];
             if (chunk_data_size > (off64_t)sizeof(buffer)) {
                 return ERROR_BUFFER_TOO_SMALL;
             }
@@ -1444,6 +1560,27 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             break;
         }
 
+        case FOURCC('w', 'a' , 'v' , 'e'):
+        {
+            //it is valid in qtmode & ver =1 & compressionId=2
+            //TODO: do those checks..
+            //.. then , we will have frma, mp4a (place holder!), esds, terminator atom!
+
+            off_t stop_offset = *offset + chunk_size;
+            *offset = data_offset;
+            while (*offset < stop_offset) {
+                status_t err = parseChunk(offset, depth + 1);
+                if (err != OK) {
+                    return err;
+                }
+            }
+
+            if (*offset != stop_offset) {
+                return ERROR_MALFORMED;
+            }
+            break;
+        }
+
         case FOURCC('-', '-', '-', '-'):
         {
             mLastCommentMean.clear();
@@ -1758,7 +1895,7 @@ sp<MediaSource> MPEG4Extractor::getTrack(size_t index) {
     }
 
     return new MPEG4Source(
-            track->meta, mDataSource, track->timescale, track->sampleTable);
+            track->meta, mDataSource, track->timescale, track->sampleTable, mStreamDurationUs);
 }
 
 // static
@@ -1868,9 +2005,7 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         numChannels = br.getBits(4);
     }
 
-    if (numChannels == 0) {
-        return ERROR_UNSUPPORTED;
-    }
+    numChannels = (numChannels == 0) ? 2 : numChannels ;
 
     int32_t prevSampleRate;
     CHECK(mLastTrack->meta->findInt32(kKeySampleRate, &prevSampleRate));
@@ -1901,7 +2036,8 @@ MPEG4Source::MPEG4Source(
         const sp<MetaData> &format,
         const sp<DataSource> &dataSource,
         int32_t timeScale,
-        const sp<SampleTable> &sampleTable)
+        const sp<SampleTable> &sampleTable,
+        int64_t streamDurationUs)
     : mFormat(format),
       mDataSource(dataSource),
       mTimescale(timeScale),
@@ -1910,14 +2046,20 @@ MPEG4Source::MPEG4Source(
       mIsAVC(false),
       mNALLengthSize(0),
       mStarted(false),
+      mFilesize(0),
       mGroup(NULL),
       mBuffer(NULL),
       mWantsNALFragments(false),
-      mSrcBuffer(NULL) {
+      mSrcBuffer(NULL),
+      mStreamDurationUs(streamDurationUs) {
     const char *mime;
     bool success = mFormat->findCString(kKeyMIMEType, &mime);
     CHECK(success);
 
+    if (mDataSource->getSize(&mFilesize) != OK) {
+        mFilesize = 0;
+    }
+
     mIsAVC = !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC);
 
     if (mIsAVC) {
@@ -2048,7 +2190,7 @@ status_t MPEG4Source::read(
 
         uint32_t sampleIndex;
         status_t err = mSampleTable->findSampleAtTime(
-                seekTimeUs * mTimescale / 1000000,
+                (seekTimeUs * mTimescale / 1000000.0)+0.5,
                 &sampleIndex, findFlags);
 
         if (mode == ReadOptions::SEEK_CLOSEST) {
@@ -2062,6 +2204,14 @@ status_t MPEG4Source::read(
         if (err == OK) {
             err = mSampleTable->findSyncSampleNear(
                     sampleIndex, &syncSampleIndex, findFlags);
+
+            if(!syncSampleIndex && (err !=OK))
+            {
+                //might be there is no sync frame post seek time.check for closest seek frame.
+                findFlags = SampleTable::kFlagClosest;
+                err = mSampleTable->findSyncSampleNear(
+                    sampleIndex, &syncSampleIndex, findFlags);
+            }
         }
 
         uint32_t sampleTime;
@@ -2123,6 +2273,30 @@ status_t MPEG4Source::read(
             return err;
         }
 
+        // If the sample has unreasonably high sampleTime
+        // then discard it, and take next sample/sampleTime
+        // We do risk loosing a sync frame due to this though
+        int8_t count = 0;
+        while (mStreamDurationUs > 0 &&
+            ((((int64_t)cts * 1000000)/mTimescale) > mStreamDurationUs)) {
+           LOGW("Sample has unreasonably high sample time %lld Usecs (stream duration is %lld Usecs) discarding it",
+                ((int64_t)cts * 1000000)/mTimescale, mStreamDurationUs);
+           ++mCurrentSampleIndex;
+           count++;
+           status_t err =
+               mSampleTable->getMetaDataForSample(
+                       mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample);
+
+           if (err != OK) {
+               return err;
+           }
+           // Avoid ANR in case too many samples have ts more than stream duration
+           if (count > 5) {
+               LOGE("Bailout many samples have timestamp more than streamDuration");
+               return ERROR_MALFORMED;
+           }
+        }
+
         err = mGroup->acquire_buffer(&mBuffer);
 
         if (err != OK) {
@@ -2139,8 +2313,10 @@ status_t MPEG4Source::read(
             if (num_bytes_read < (ssize_t)size) {
                 mBuffer->release();
                 mBuffer = NULL;
-
-                return ERROR_IO;
+                if (mFilesize && ((offset + size) > mFilesize))
+                    return ERROR_END_OF_STREAM;
+                else
+                    return ERROR_IO;
             }
 
             CHECK(mBuffer != NULL);
@@ -2219,8 +2395,10 @@ status_t MPEG4Source::read(
         if (num_bytes_read < (ssize_t)size) {
             mBuffer->release();
             mBuffer = NULL;
-
-            return ERROR_IO;
+            if (mFilesize && ((offset + size) > mFilesize))
+                return ERROR_END_OF_STREAM;
+            else
+                return ERROR_IO;
         }
 
         if (usesDRM) {
@@ -2245,7 +2423,8 @@ status_t MPEG4Source::read(
                     ALOGE("Video is malformed");
                     mBuffer->release();
                     mBuffer = NULL;
-                    return ERROR_MALFORMED;
+                    ++mCurrentSampleIndex;
+                    return INFO_DISCONTINUITY;
                 }
 
                 if (nalLength == 0) {
@@ -2317,7 +2496,8 @@ static bool LegacySniffMPEG4(
         || !memcmp(header, "ftyp3ge6", 8) || !memcmp(header, "ftyp3gg6", 8)
         || !memcmp(header, "ftypisom", 8) || !memcmp(header, "ftypM4V ", 8)
         || !memcmp(header, "ftypM4A ", 8) || !memcmp(header, "ftypf4v ", 8)
-        || !memcmp(header, "ftypkddi", 8) || !memcmp(header, "ftypM4VP", 8)) {
+        || !memcmp(header, "ftypkddi", 8) || !memcmp(header, "ftypM4VP", 8)
+        || !memcmp(header, "ftypqt  ", 8) || !memcmp(header, "ftypQT  ", 8)) {
         *mimeType = MEDIA_MIMETYPE_CONTAINER_MPEG4;
         *confidence = 0.4;
 
@@ -2335,6 +2515,7 @@ static bool isCompatibleBrand(uint32_t fourcc) {
         FOURCC('3', 'g', 'p', '4'),
         FOURCC('m', 'p', '4', '1'),
         FOURCC('m', 'p', '4', '2'),
+        FOURCC('m', 'm', 'p', '4'),
 
         // Won't promise that the following file types can be played.
         // Just give these file types a chance.
@@ -2343,6 +2524,10 @@ static bool isCompatibleBrand(uint32_t fourcc) {
 
         FOURCC('3', 'g', '2', 'a'),  // 3GPP2
         FOURCC('3', 'g', '2', 'b'),
+        FOURCC('3', 'g', 'p', '5'),
+        FOURCC('3', 'g', 'p', '6'),
+        FOURCC('k', '3', 'g', '1'),
+        FOURCC('w', 'm', 'f', ' '),
     };
 
     for (size_t i = 0;
@@ -2469,6 +2654,30 @@ static bool BetterSniffMPEG4(
     return true;
 }
 
+//mov files with moov atom and mdat atom also valid ones.
+static bool MovSniffMPEG4(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence) {
+    uint8_t header[12];
+    if (source->readAt(0, header, 12) != 12
+        || memcmp("moov", &header[4], 4)) {
+        return false;
+    }
+
+    size_t atomSize = U32_AT(&header[0]);
+    if (atomSize < 16 ) {
+        return false;
+    }
+
+    if (source->readAt(atomSize, header, 12) != 12
+        || memcmp("mdat", &header[4], 4)) {
+        return false;
+    }
+
+    *mimeType = MEDIA_MIMETYPE_CONTAINER_MPEG4;
+    *confidence = 0.4f;
+
+    return true;
+}
 bool SniffMPEG4(
         const sp<DataSource> &source, String8 *mimeType, float *confidence,
         sp<AMessage> *meta) {
@@ -2481,6 +2690,12 @@ bool SniffMPEG4(
         return true;
     }
 
+    //one more try!
+    //moov and mdat
+    if (MovSniffMPEG4(source, mimeType, confidence)) {
+        return true;
+    }
+
     return false;
 }
 
diff --git a/media/libstagefright/SampleIterator.cpp b/media/libstagefright/SampleIterator.cpp
index eae721b..e419d7b 100644
--- a/media/libstagefright/SampleIterator.cpp
+++ b/media/libstagefright/SampleIterator.cpp
@@ -293,7 +293,12 @@ status_t SampleIterator::findSampleTime(
 
     while (sampleIndex >= mTTSSampleIndex + mTTSCount) {
         if (mTimeToSampleIndex == mTable->mTimeToSampleCount) {
-            return ERROR_OUT_OF_RANGE;
+            if (sampleIndex == mTTSSampleIndex + mTTSCount) {
+                *time = mTTSSampleTime + mTTSDuration * (sampleIndex - mTTSSampleIndex);
+                *time += mTable->getCompositionTimeOffset(sampleIndex);
+            } else {
+                return ERROR_OUT_OF_RANGE;
+            }
         }
 
         mTTSSampleIndex += mTTSCount;
diff --git a/media/libstagefright/SampleTable.cpp b/media/libstagefright/SampleTable.cpp
index d9858d7..c341958 100644
--- a/media/libstagefright/SampleTable.cpp
+++ b/media/libstagefright/SampleTable.cpp
@@ -27,6 +27,8 @@
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/Utils.h>
 
+#define MAX_SAMPLE_SIZE 4294967296
+
 namespace android {
 
 // static
@@ -280,6 +282,12 @@ status_t SampleTable::setSampleSizeParams(
     mDefaultSampleSize = U32_AT(&header[4]);
     mNumSampleSizes = U32_AT(&header[8]);
 
+    if (((uint64_t)mNumSampleSizes * (uint64_t)mDefaultSampleSize) > MAX_SAMPLE_SIZE)
+    {
+        LOGE("Sample Table size exceed 4GB");
+        return ERROR_MALFORMED;
+    }
+
     if (type == kSampleSizeType32) {
         mSampleSizeFieldSize = 32;
 
@@ -326,7 +334,11 @@ status_t SampleTable::setTimeToSampleParams(
 
     if (U32_AT(header) != 0) {
         // Expected version = 0, flags = 0.
-        return ERROR_MALFORMED;
+        // If it's not, let's assume this is one of those
+        // apparently malformed chunks that don't have flags
+        // and completely different semantics than what's
+        // in the MPEG4 specs and skip it.
+        return OK;
     }
 
     mTimeToSampleCount = U32_AT(&header[4]);
@@ -367,7 +379,7 @@ status_t SampleTable::setCompositionTimeToSampleParams(
 
     size_t numEntries = U32_AT(&header[4]);
 
-    if (data_size != (numEntries + 1) * 8) {
+    if (data_size < (numEntries + 1) * 8) {
         return ERROR_MALFORMED;
     }
 
@@ -417,6 +429,9 @@ status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size)
         ALOGV("Table of sync samples is empty or has only a single entry!");
     }
 
+    if (mNumSyncSamples == 0) {
+        mSyncSampleOffset = -1;
+    }
     mSyncSamples = new uint32_t[mNumSyncSamples];
     size_t size = mNumSyncSamples * sizeof(uint32_t);
     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)
@@ -637,6 +652,9 @@ status_t SampleTable::findSyncSampleNear(
             ALOGE("tried to find a sync frame after the last one: %d", left);
             return ERROR_OUT_OF_RANGE;
         }
+    }
+
+    if (left > 0) {
         left = left - 1;
     }
 
@@ -666,7 +684,8 @@ status_t SampleTable::findSyncSampleNear(
 
         err = mSampleIterator->seekTo(y);
         if (err != OK) {
-            return err;
+            *sample_index = x++;
+            return OK;
         }
 
         uint32_t y_time = mSampleIterator->getSampleTime();
diff --git a/media/libstagefright/include/MPEG4Extractor.h b/media/libstagefright/include/MPEG4Extractor.h
index 5c549e0..8577128 100644
--- a/media/libstagefright/include/MPEG4Extractor.h
+++ b/media/libstagefright/include/MPEG4Extractor.h
@@ -54,11 +54,14 @@ private:
         sp<SampleTable> sampleTable;
         bool includes_expensive_metadata;
         bool skipTrack;
+        bool esds_success;
+        bool TerminatorAtomReached;
     };
 
     sp<DataSource> mDataSource;
     status_t mInitCheck;
     bool mHasVideo;
+    int64_t mStreamDurationUs;
 
     Track *mFirstTrack, *mLastTrack;
 
@@ -97,6 +100,8 @@ private:
 
     MPEG4Extractor(const MPEG4Extractor &);
     MPEG4Extractor &operator=(const MPEG4Extractor &);
+
+    int m_qtmode; // 1 - mov;qt;  0-iso mode;
 };
 
 bool SniffMPEG4(
-- 
1.7.1

