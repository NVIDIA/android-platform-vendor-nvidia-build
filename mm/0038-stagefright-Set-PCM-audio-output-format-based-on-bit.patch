From 2a6aefc467834eea9e8637fc6e1974ececef0823 Mon Sep 17 00:00:00 2001
From: Yogesh Agrawal <yagrawal@nvidia.com>
Date: Mon, 13 Aug 2012 14:55:45 +0530
Subject: [PATCH 38/40] stagefright: Set PCM audio output format based on bits per sample

 - By default always the audio output format is set to PCM 16 bit.
   Setting the appropriate PCM audio output format based on
   bits per sample.
 - Missing integration of ULP

Reviewed-on: http://git-master/r/105664
(cherry picked from commit e843512292e2d8b62b40abe168c8214cc9928cd6)

Bug 992716
Bug 993129

Change-Id: I5f3bf2e4d20d5fffb583c0d9075c8d96a73abdbe
---
 media/libstagefright/AudioPlayer.cpp |   42 ++++++++++++++++++++++++++++++++++
 1 files changed, 42 insertions(+), 0 deletions(-)

diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index 08af5ef..133c4df 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -190,6 +190,21 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
         // sending compressed audio as it is
         CHECK(numChannels == 2);
         mAudioFormat = AUDIO_FORMAT_AAC;
+    } else {
+        int32_t bitsPerSample;
+        if (format->findInt32(kKeyBitsPerSample, &bitsPerSample)) {
+            switch (bitsPerSample) {
+                case 8:
+                    mAudioFormat = AUDIO_FORMAT_PCM_8_BIT;
+                    break;
+                case 24:
+                    mAudioFormat = AUDIO_FORMAT_PCM_8_24_BIT;
+                    break;
+                case 16:
+                default:
+                    mAudioFormat = AUDIO_FORMAT_PCM_16_BIT;
+            }
+        }
     }
 
     if (mAudioSink.get() != NULL) {
@@ -480,6 +495,33 @@ void AudioPlayer::onPortSettingsChangedEvent() {
 
     ALOGV("New sample rate %d channels %d", mSampleRate, numChannels);
 
+    if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG) ||
+        !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II)) {
+        // sending compressed audio as it is
+        CHECK(numChannels == 2);
+        mAudioFormat = AUDIO_FORMAT_MP3;
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
+        // sending compressed audio as it is
+        CHECK(numChannels == 2);
+        mAudioFormat = AUDIO_FORMAT_AAC;
+    } else {
+        int32_t bitsPerSample;
+        if (format->findInt32(kKeyBitsPerSample, &bitsPerSample)) {
+            switch (bitsPerSample) {
+                case 8:
+                    mAudioFormat = AUDIO_FORMAT_PCM_8_BIT;
+                    break;
+                case 24:
+                    mAudioFormat = AUDIO_FORMAT_PCM_8_24_BIT;
+                    break;
+                case 16:
+                default:
+                    mAudioFormat = AUDIO_FORMAT_PCM_16_BIT;
+            }
+        }
+    }
+
+
     if (mAudioSink.get() != NULL) {
         err = mAudioSink->open(
                  mSampleRate, numChannels, channelMask, AUDIO_FORMAT_PCM_16_BIT,
-- 
1.7.1

