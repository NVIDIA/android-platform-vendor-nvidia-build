From ce3a593306cfb6bd5e6331b87a094b1da1d077f3 Mon Sep 17 00:00:00 2001
From: Aniruddha <aniruddhac@nvidia.com>
Date: Fri, 2 Nov 2012 18:36:59 +0530
Subject: [PATCH 19/40] Send CSD data if discontinuity

During RTSP streaming, if discontinuity is sent when
initial seek is performed, and the CSD data is not
consumed by the decoder then, it is flushed.
So, resend the CSD data so that decoder can get CSD.
If we do not resend it then decoder will indefinitely
wait for the same.

Bug 920742

Integration for the commit:
http://git-master/r/77284

Change-Id: Ia3c9b8cbe7befd02991a0226d91448f33672fd80

[JB]RTSP related commits

This CL is a integration for following commits:
http://git-master/r/102243 [RTSP Streaming] Fix RTSP live streaming issue
http://git-master/r/44938 [SF streaming] Get proper dimension of video track

Bug 991874

Change-Id: I335865c78394d11e5b752f44543d5f6a3ec37a9b

[SF Streaming] RTSP PAUSE and other commits.

This CL is a integration for following commits:
http://git-master/r/86595 [SF Streaming] Implement RTSP PAUSE
http://git-master/r/86133 [SF Streaming] Disable AV queues sync. after EOS.
http://git-master/r/76491 [NuPlayer] Correct AudioSink Latency

Change-Id: Ib361f94f4e887848b1e0dc1156153498a09c7bc8

[SF Streaming] RTSP related commits

This CL is a integration for following commits:
http://git-master/r/86324 [SF Streaming] Add extra check for live streaming.
http://git-master/r/86350 [SF Streaming] Queue seeks in MyHandler
http://git-master/r/96448 [SF STREAMING] Adds NULL checks for mHandler

Change-Id: Icd489a0a829f820e007c18071c219ffbadcfe903

NuPlayer: fix crashes and pauses in abq playback.

AAC decoder sends port setting change for input port
As Acodec does not support input port setting change,
it crashes.
Ignore port setting change for input port until it is not
supported

After signalling Time Discontinuity,nuplayer checks whether renderer
queues are empty assuming that it is already flushed.
Flush the renderer queues before decoder to avoid crash.

In case of format change, nuplayer shouldn't
flush/close decoder decoder.
If next access unit has different mime type, then nuplayer will
flush/close decoder.
If client has set kKeyFormatChange in discontinuity cmd,
then esQueue should only clear format not buffers.
In format discontinuity handling, AnotherPacketSource shouldn't
flush buffer queue.

Bug 1013944
Bug 943695
Bug 908711
Bug 911804
Reviewed-on: http://git-master/r/#change,67380
Reviewed-on: http://git-master/r/#change,86830
Reviewed-On: http://git-master/r/70520

Change-Id: Ic83fb3b2b391b9bb2180601b8f6e442769d2d856
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  139 ++++++++++++++++---
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |    5 +-
 .../nuplayer/NuPlayerDecoder.cpp                   |   12 ++
 .../nuplayer/NuPlayerDecoder.h                     |    4 +
 .../nuplayer/NuPlayerRenderer.cpp                  |    8 +-
 .../nuplayer/NuPlayerSource.h                      |   10 ++
 .../libmediaplayerservice/nuplayer/RTSPSource.cpp  |   37 +++++-
 media/libmediaplayerservice/nuplayer/RTSPSource.h  |    3 +
 media/libstagefright/ACodec.cpp                    |   11 ++-
 media/libstagefright/mpeg2ts/ATSParser.cpp         |   25 +++-
 .../libstagefright/mpeg2ts/AnotherPacketSource.cpp |   30 +++--
 media/libstagefright/rtsp/ASessionDescription.cpp  |   42 +++++-
 media/libstagefright/rtsp/MyHandler.h              |  148 +++++++++++++++++++-
 13 files changed, 423 insertions(+), 51 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 813f1d5..7df14cd 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -81,7 +81,9 @@ NuPlayer::NuPlayer()
       mProfFlags(0ll),
       mFirstFrame(true),
 #endif
-      mNumFramesDropped(0ll) {
+      mNumFramesDropped(0ll),
+      mAudioFormatChange(false),
+      mVideoFormatChange(false) {
 }
 
 NuPlayer::~NuPlayer() {
@@ -398,7 +400,7 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                     }
 #endif
                 } else {
-                    ALOGV("got %s decoder EOS w/ error %d",
+                    ALOGE("got %s decoder EOS w/ error %d",
                          audio ? "audio" : "video",
                          err);
                 }
@@ -417,7 +419,7 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                     mVideoLateByUs = 0;
                 }
 
-                ALOGV("decoder %s flush completed", audio ? "audio" : "video");
+                ALOGD("decoder %s flush completed", audio ? "audio" : "video");
 
                 if (needShutdown) {
                     ALOGV("initiating %s decoder shutdown",
@@ -701,6 +703,10 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 
         case kWhatPause:
         {
+            if (mIsRtspStreaming) {
+                mSource->pause();
+            }
+
             CHECK(mRenderer != NULL);
             mRenderer->pause();
             break;
@@ -710,6 +716,10 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
         {
             CHECK(mRenderer != NULL);
             mRenderer->resume();
+
+            if (mIsRtspStreaming) {
+                mSource->resume();
+            }
             break;
         }
 
@@ -721,10 +731,12 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 
 void NuPlayer::finishFlushIfPossible() {
     if (mFlushingAudio != FLUSHED && mFlushingAudio != SHUT_DOWN) {
+        ALOGE("mFlushingAudio != FLUSHED && mFlushingAudio != SHUT_DOWN.");
         return;
     }
 
     if (mFlushingVideo != FLUSHED && mFlushingVideo != SHUT_DOWN) {
+        ALOGE("mFlushingVideo != FLUSHED && mFlushingVideo != SHUT_DOWN.");
         return;
     }
 
@@ -804,11 +816,20 @@ status_t NuPlayer::instantiateDecoder(bool audio, sp<Decoder> *decoder) {
         return -EWOULDBLOCK;
     }
 
+//    const char *mime;
+//    CHECK(meta->findCString(kKeyMIMEType, &mime));
+    AString mime;
+    CHECK(format->findString("mime", &mime));
+
+    ALOGV("%s: %s -> mime %s \n",
+        __FUNCTION__, audio ? "audio" : "video", mime.c_str());
     if (!audio) {
-        AString mime;
-        CHECK(format->findString("mime", &mime));
+        mInitialMimeVideo = mime;
         mVideoIsAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str());
     }
+    else {
+        mInitialMimeAudio = mime;
+    }
 
     sp<AMessage> notify =
         new AMessage(audio ? kWhatAudioNotify : kWhatVideoNotify,
@@ -857,11 +878,17 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
         if (err == -EWOULDBLOCK) {
             return err;
         } else if (err != OK) {
+            bool &mediaFormatChange = audio ? mAudioFormatChange : mVideoFormatChange;
+            bool bSkipThisBuffer = false;
+            mediaFormatChange = false;
             if (err == INFO_DISCONTINUITY) {
                 int32_t type;
-                CHECK(accessUnit->meta()->findInt32("discontinuity", &type));
+                int32_t keyFormatChange = 0;
+                sp<AMessage> extra = NULL;
 
-                bool formatChange =
+                CHECK(accessUnit->meta()->findInt32("discontinuity", &type));
+                accessUnit->meta()->findMessage("extra", &extra);
+                mediaFormatChange =
                     (audio &&
                      (type & ATSParser::DISCONTINUITY_AUDIO_FORMAT))
                     || (!audio &&
@@ -869,15 +896,26 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
 
                 bool timeChange = (type & ATSParser::DISCONTINUITY_TIME) != 0;
 
-                ALOGI("%s discontinuity (formatChange=%d, time=%d)",
-                     audio ? "audio" : "video", formatChange, timeChange);
+                ALOGI("%s discontinuity (formatChange=%d, time=%d) type 0x%x",
+                     audio ? "audio" : "video", mediaFormatChange, timeChange, type);
+
+                if (mediaFormatChange && (extra != NULL)) {
+                    int32_t formatChange = 0;
+                    extra->findInt32(
+                        IStreamListener::kKeyDiscontinuityMask,
+                        (int32_t *)&formatChange);
+                    formatChange = formatChange & ATSParser::DISCONTINUITY_FORMATCHANGE;
+                    bSkipThisBuffer = ((formatChange == ATSParser::DISCONTINUITY_FORMATCHANGE) ||
+                                   (formatChange == ATSParser::DISCONTINUITY_VIDEO_FORMAT));
+                    ALOGV("NU: IStreamListener::kKeyDiscontinuityMask %d skip %d time change %d \n",
+                        formatChange, (int)bSkipThisBuffer, (int)timeChange);
+                }
 
                 if (audio) {
                     mSkipRenderingAudioUntilMediaTimeUs = -1;
                 } else {
                     mSkipRenderingVideoUntilMediaTimeUs = -1;
                 }
-
                 if (timeChange) {
                     sp<AMessage> extra;
                     if (accessUnit->meta()->findMessage("extra", &extra)
@@ -902,11 +940,17 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
                 mTimeDiscontinuityPending =
                     mTimeDiscontinuityPending || timeChange;
 
-                if (formatChange || timeChange) {
-                    flushDecoder(audio, formatChange);
-                } else {
+                if (!bSkipThisBuffer && (mediaFormatChange || timeChange)) {
+                    flushDecoder(audio, mediaFormatChange);
+                    mediaFormatChange = false;
+                }
+                else if (bSkipThisBuffer) {
+                    mFlushingAudio = NONE;
+                    mFlushingVideo = NONE;
+                    continue;
+                }
+                else {
                     // This stream is unaffected by the discontinuity
-
                     if (audio) {
                         mFlushingAudio = FLUSHED;
                     } else {
@@ -914,13 +958,33 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
                     }
 
                     finishFlushIfPossible();
-
+                    ALOGI("%s: %s discontinuity -EWOULDBLOCK ", __FUNCTION__,
+                     audio ? "audio" : "video");
                     return -EWOULDBLOCK;
                 }
+                if ((type & ATSParser::DISCONTINUITY_TIME) && (mIsRtspStreaming)) {
+                    if (!audio && mVideoIsAVC) {
+                        ALOGV("Time Discontinuity detected. Sending CSD again to the decoder...");
+                        size_t csdIndex, size;
+                        size = mVideoDecoder->getCsdSize();
+
+                        for (csdIndex = 0; csdIndex < size; csdIndex++) {
+                            sp<ABuffer> outBuffer;
+                            outBuffer = mVideoDecoder->getCsdAtIndex(csdIndex);
+                            outBuffer->meta()->setInt64("timeUs", 0);
+
+                            CHECK(mIsRtspStreaming);
+                            sp<RTSPSource> source;
+                            source = static_cast<RTSPSource *>(mSource.get());
+                            source->queueCsd(audio, outBuffer);
+                        }
+                    }
+                }
             }
-
             reply->setInt32("err", err);
             reply->post();
+            ALOGI("%s: %s discontinuity err 0x%x ", __FUNCTION__,
+                     audio ? "audio" : "video", err);
             return OK;
         }
 
@@ -951,6 +1015,45 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
          audio ? "audio" : "video",
          mediaTimeUs / 1E6);
 #endif
+    bool &formatChange = audio ? mAudioFormatChange : mVideoFormatChange;
+    if (formatChange)
+    {
+        bool shutDownDecoder = false;
+        sp<AMessage> meta = mSource->getFormat(audio);
+
+        if (meta != NULL) {
+            AString newMime;
+            CHECK(meta->findString("mime", &newMime));
+            if (!audio)
+            {
+                if (strcmp(mInitialMimeVideo.c_str(),newMime.c_str()))
+                {
+                    mInitialMimeVideo = newMime;
+                    shutDownDecoder = true;
+                }
+            }
+            else
+            {
+                if (strcmp(mInitialMimeAudio.c_str(),newMime.c_str()))
+                {
+                    mInitialMimeAudio = newMime;
+                    shutDownDecoder = true;
+                }
+            }
+            if (shutDownDecoder)
+            {
+                ALOGI("####FormatChange:%s valid buffer of %s data",
+                    newMime.c_str(), audio ? "audio" : "video");
+                flushDecoder(audio, shutDownDecoder);
+            }
+            formatChange = false;
+        }
+        else
+        {
+            ALOGV("%s: %s -> check format next time \n",
+                __FUNCTION__, audio ? "audio" : "video");
+        }
+    }
 
     reply->setBuffer("buffer", accessUnit);
     reply->post();
@@ -1028,13 +1131,15 @@ void NuPlayer::flushDecoder(bool audio, bool needShutdown) {
     ++mScanSourcesGeneration;
     mScanSourcesPending = false;
 
-    (audio ? mAudioDecoder : mVideoDecoder)->signalFlush();
     mRenderer->flush(audio);
+    (audio ? mAudioDecoder : mVideoDecoder)->signalFlush();
 
     FlushStatus newStatus =
         needShutdown ? FLUSHING_DECODER_SHUTDOWN : FLUSHING_DECODER;
 
     if (audio) {
+        ALOGI("flushDecoder %s decoder present mFlushingAudio 0x%x ",
+            audio ? "audio" : "video", mFlushingAudio);
         CHECK(mFlushingAudio == NONE
                 || mFlushingAudio == AWAITING_DISCONTINUITY);
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index 39033dd..238585b 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -157,12 +157,15 @@ private:
     FlushStatus mFlushingVideo;
     bool mResetInProgress;
     bool mResetPostponed;
-
     int64_t mSkipRenderingAudioUntilMediaTimeUs;
     int64_t mSkipRenderingVideoUntilMediaTimeUs;
 
     int64_t mVideoLateByUs;
     int64_t mNumFramesTotal, mNumFramesDropped;
+    AString mInitialMimeVideo;
+    AString mInitialMimeAudio;
+    bool mAudioFormatChange;
+    bool mVideoFormatChange;
 
     int32_t mVideoScalingMode;
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index 8fa6116..03db13c 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -104,6 +104,18 @@ void NuPlayer::Decoder::onMessageReceived(const sp<AMessage> &msg) {
     }
 }
 
+size_t NuPlayer::Decoder::getCsdSize() {
+    return mCSD.size();
+}
+
+sp<ABuffer> NuPlayer::Decoder::getCsdAtIndex(const size_t index) {
+    if (mCSD.isEmpty())
+        return NULL;
+
+    CHECK_LE(index, mCSD.size());
+    return mCSD.editItemAt(index);
+}
+
 void NuPlayer::Decoder::onFillThisBuffer(const sp<AMessage> &msg) {
     sp<AMessage> reply;
     CHECK(msg->findMessage("reply", &reply));
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
index 03a0707..3ea93f9 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
@@ -35,10 +35,14 @@ struct NuPlayer::Decoder : public AHandler {
     void signalFlush();
     void signalResume();
     void initiateShutdown();
+
 #ifdef PROFILING
     void enableProfileFlags();
 #endif
 
+    size_t getCsdSize();
+    sp<ABuffer> getCsdAtIndex(const size_t index);
+
 protected:
     virtual ~Decoder();
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index e9c23f2..be702eb 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -74,8 +74,7 @@ void NuPlayer::Renderer::queueBuffer(
 }
 
 void NuPlayer::Renderer::queueEOS(bool audio, status_t finalResult) {
-    CHECK_NE(finalResult, (status_t)OK);
-
+    LOGE("NuPlayer::Renderer::queueEOS finalResult 0x%x \n", finalResult);
     sp<AMessage> msg = new AMessage(kWhatQueueEOS, id());
     msg->setInt32("audio", static_cast<int32_t>(audio));
     msg->setInt32("finalResult", finalResult);
@@ -104,7 +103,6 @@ void NuPlayer::Renderer::signalTimeDiscontinuity() {
     CHECK(mVideoQueue.empty());
     mAnchorTimeMediaUs = -1;
     mAnchorTimeRealUs = -1;
-    mSyncQueues = mHasAudio && mHasVideo;
 }
 
 void NuPlayer::Renderer::pause() {
@@ -280,7 +278,7 @@ bool NuPlayer::Renderer::onDrainAudioQueue() {
                 mNumFramesWritten - numFramesPlayed;
 
             int64_t realTimeOffsetUs =
-                (mAudioSink->latency() / 2  /* XXX */
+                (mAudioSink->latency()
                     + numFramesPendingPlayout
                         * mAudioSink->msecsPerFrame()) * 1000ll;
 
@@ -532,6 +530,7 @@ void NuPlayer::Renderer::onQueueEOS(const sp<AMessage> &msg) {
     QueueEntry entry;
     entry.mOffset = 0;
     entry.mFinalResult = finalResult;
+    mSyncQueues = false;
 
     if (audio) {
         mAudioQueue.push_back(entry);
@@ -554,6 +553,7 @@ void NuPlayer::Renderer::onFlush(const sp<AMessage> &msg) {
     // corresponding discontinuity on the other queue.
     // Therefore we'll stop syncing the queues if at least one of them
     // is flushed.
+    mSyncQueues = mHasAudio && mHasVideo;
     syncQueuesDone();
 
     if (audio) {
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerSource.h b/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
index 91b5c57..51a24de 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
@@ -54,6 +54,16 @@ struct NuPlayer::Source : public RefBase {
         return false;
     }
 
+    virtual status_t queueCsd(bool audio, sp<ABuffer> &csd) {
+        return INVALID_OPERATION;
+    }
+
+    virtual void pause() {
+    }
+
+    virtual void resume() {
+    }
+
 protected:
     virtual ~Source() {}
 
diff --git a/media/libmediaplayerservice/nuplayer/RTSPSource.cpp b/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
index 501597f..ba31f28 100644
--- a/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
@@ -164,6 +164,30 @@ status_t NuPlayer::RTSPSource::dequeueAccessUnit(
     return source->dequeueAccessUnit(accessUnit);
 }
 
+status_t NuPlayer::RTSPSource::queueCsd(
+        bool audio, sp<ABuffer> &csd) {
+    sp<AnotherPacketSource> source = getSource(audio);
+
+    if (source == NULL) {
+        return -EWOULDBLOCK;
+    }
+
+    source->queueAccessUnit(csd);
+    return OK;
+}
+
+void NuPlayer::RTSPSource::pause() {
+     if (mState == CONNECTED && mHandler != NULL) {
+         mHandler->pause();
+     }
+}
+
+void NuPlayer::RTSPSource::resume() {
+     if (mState == CONNECTED && mHandler != NULL) {
+         mHandler->resume();
+     }
+}
+
 sp<AnotherPacketSource> NuPlayer::RTSPSource::getSource(bool audio) {
     if (mTSParser != NULL) {
         sp<MediaSource> source = mTSParser->getSource(
@@ -217,13 +241,15 @@ status_t NuPlayer::RTSPSource::seekTo(int64_t seekTimeUs) {
 }
 
 void NuPlayer::RTSPSource::performSeek(int64_t seekTimeUs) {
-    if (mState != CONNECTED) {
-         mHandler->setPlayStartRange(seekTimeUs);
+    if (mState != CONNECTED && mHandler != NULL) {
+        mHandler->setPlayStartRange(seekTimeUs);
         return;
     }
 
-    mState = SEEKING;
-    mHandler->seek(seekTimeUs);
+    if (mHandler != NULL) {
+        mState = SEEKING;
+        mHandler->seek(seekTimeUs);
+    }
 }
 
 bool NuPlayer::RTSPSource::isSeekable() {
@@ -438,6 +464,7 @@ void NuPlayer::RTSPSource::onMessageReceived(const sp<AMessage> &msg) {
 void NuPlayer::RTSPSource::onConnected() {
     CHECK(mAudioTrack == NULL);
     CHECK(mVideoTrack == NULL);
+    CHECK(mHandler != NULL);
 
     size_t numTracks = mHandler->countTracks();
     for (size_t i = 0; i < numTracks; ++i) {
@@ -503,7 +530,7 @@ void NuPlayer::RTSPSource::onDisconnected(const sp<AMessage> &msg) {
 }
 
 void NuPlayer::RTSPSource::finishDisconnectIfPossible() {
-    if (mState != DISCONNECTED) {
+    if (mState != DISCONNECTED && mHandler != NULL) {
         mHandler->disconnect();
         return;
     }
diff --git a/media/libmediaplayerservice/nuplayer/RTSPSource.h b/media/libmediaplayerservice/nuplayer/RTSPSource.h
index a7239ba..bdaa74a 100644
--- a/media/libmediaplayerservice/nuplayer/RTSPSource.h
+++ b/media/libmediaplayerservice/nuplayer/RTSPSource.h
@@ -39,10 +39,13 @@ struct NuPlayer::RTSPSource : public NuPlayer::Source {
 
     virtual void start();
     virtual void stop();
+    virtual void pause();
+    virtual void resume();
 
     virtual status_t feedMoreTSData();
 
     virtual status_t dequeueAccessUnit(bool audio, sp<ABuffer> *accessUnit);
+    virtual status_t queueCsd(bool audio, sp<ABuffer> &csd);
 
     virtual status_t getDuration(int64_t *durationUs);
     virtual status_t seekTo(int64_t seekTimeUs);
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 85e48ab..0ee908b 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -730,7 +730,10 @@ status_t ACodec::freeOutputBuffersNotOwnedByComponent() {
                 BufferInfo::OWNED_BY_COMPONENT) {
             // We shouldn't have sent out any buffers to the client at this
             // point.
-            CHECK_NE((int)info->mStatus, (int)BufferInfo::OWNED_BY_DOWNSTREAM);
+            if ((int)info->mStatus == (int)BufferInfo::OWNED_BY_DOWNSTREAM) {
+                LOGV("Delay freeing downstream buffers, instead of a CHECK at this point");
+                continue;
+            }
 
             CHECK_EQ((status_t)OK, freeBuffer(kPortIndexOutput, i));
         }
@@ -3513,8 +3516,12 @@ bool ACodec::ExecutingState::onOMXEvent(
     switch (event) {
         case OMX_EventPortSettingsChanged:
         {
+            if (data1 == (OMX_U32)kPortIndexInput)
+            {
+                // ignore port setting change for input as it is not yet supported
+                return true;
+            }
             CHECK_EQ(data1, (OMX_U32)kPortIndexOutput);
-
             if (data2 == 0 || data2 == OMX_IndexParamPortDefinition) {
                 CHECK_EQ(mCodec->mOMX->sendCommand(
                             mCodec->mNode,
diff --git a/media/libstagefright/mpeg2ts/ATSParser.cpp b/media/libstagefright/mpeg2ts/ATSParser.cpp
index 5310de3..6e948ef 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -760,6 +760,8 @@ void ATSParser::Stream::signalDiscontinuity(
     mBuffer->setRange(0, 0);
 
     bool clearFormat = false;
+    int32_t formatChange = 0;
+    bool bClearQueue = true;
     if (isAudio()) {
         if (type & DISCONTINUITY_AUDIO_FORMAT) {
             clearFormat = true;
@@ -770,7 +772,22 @@ void ATSParser::Stream::signalDiscontinuity(
         }
     }
 
-    mQueue->clear(clearFormat);
+    if ((type & DISCONTINUITY_FORMATCHANGE) && extra != NULL)
+    {
+        extra->findInt32(
+                IStreamListener::kKeyDiscontinuityMask,
+                (int32_t *)&formatChange);
+        formatChange = formatChange & ATSParser::DISCONTINUITY_FORMATCHANGE;
+        bClearQueue = ((formatChange != ATSParser::DISCONTINUITY_FORMATCHANGE) &&
+                       (formatChange != ATSParser::DISCONTINUITY_VIDEO_FORMAT));
+        LOGI("TS: IStreamListener::kKeyDiscontinuityMask %d clear %d type 0x%x \n",
+            formatChange, (int)bClearQueue, type);
+    }
+    if (bClearQueue)
+    {
+        LOGD("%s: mQueue->clear type 0x%x \n", __FUNCTION__, type);
+        mQueue->clear(clearFormat);
+    }
 
     if (type & DISCONTINUITY_TIME) {
         uint64_t resumeAtPTS;
@@ -783,9 +800,11 @@ void ATSParser::Stream::signalDiscontinuity(
 
             extra->setInt64("resume-at-mediatimeUs", resumeAtMediaTimeUs);
         }
+        if (mSource != NULL) {
+            mSource->queueDiscontinuity(type, extra);
+        }
     }
-
-    if (mSource != NULL) {
+    else if (mSource != NULL && clearFormat) {
         mSource->queueDiscontinuity(type, extra);
     }
 }
diff --git a/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp b/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp
index a605a05..e18b6ca 100644
--- a/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp
+++ b/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp
@@ -14,6 +14,10 @@
  * limitations under the License.
  */
 
+//#define LOG_NDEBUG 0
+#define LOG_TAG "AnotherPacketSource"
+#include <media/stagefright/foundation/ADebug.h>
+
 #include "AnotherPacketSource.h"
 
 #include <media/stagefright/foundation/ABuffer.h>
@@ -156,18 +160,22 @@ void AnotherPacketSource::queueDiscontinuity(
     Mutex::Autolock autoLock(mLock);
 
     // Leave only discontinuities in the queue.
-    List<sp<ABuffer> >::iterator it = mBuffers.begin();
-    while (it != mBuffers.end()) {
-        sp<ABuffer> oldBuffer = *it;
+    if (ATSParser::DISCONTINUITY_TIME & type == ATSParser::DISCONTINUITY_TIME)
+    {
+        LOGD("%s: clear old buffers \n", __FUNCTION__);
+        List<sp<ABuffer> >::iterator it = mBuffers.begin();
+        while (it != mBuffers.end()) {
+            sp<ABuffer> oldBuffer = *it;
+
+            int32_t oldDiscontinuityType;
+            if (!oldBuffer->meta()->findInt32(
+                        "discontinuity", &oldDiscontinuityType)) {
+                it = mBuffers.erase(it);
+                continue;
+            }
 
-        int32_t oldDiscontinuityType;
-        if (!oldBuffer->meta()->findInt32(
-                    "discontinuity", &oldDiscontinuityType)) {
-            it = mBuffers.erase(it);
-            continue;
+            ++it;
         }
-
-        ++it;
     }
 
     mEOSResult = OK;
diff --git a/media/libstagefright/rtsp/ASessionDescription.cpp b/media/libstagefright/rtsp/ASessionDescription.cpp
index c6b732f..9411c25 100644
--- a/media/libstagefright/rtsp/ASessionDescription.cpp
+++ b/media/libstagefright/rtsp/ASessionDescription.cpp
@@ -228,13 +228,49 @@ bool ASessionDescription::getDimensions(
     *width = 0;
     *height = 0;
 
+    bool status = false;
     char key[20];
     sprintf(key, "a=framesize:%lu", PT);
     AString value;
     if (!findAttribute(index, key, &value)) {
-        return false;
-    }
+        sprintf(key, "a=Width");
+        if (!findAttribute(index, key, &value)) {
+            char *val = strchr(value.c_str(),';');
+            if (val != NULL) {
+               val++;
+               *width = atoi(val);
+               LOGV("Width = %d",*width);
+               sprintf(key, "a=Height");
+               if (findAttribute(index, key, &value)) {
+                  char *val = strchr(value.c_str(),';');
+                  if (val != NULL) {
+                      val++;
+                      *height = atoi(val);
+                       LOGV("Height = %d",*height);
+                       status = true;
+                  }
+               }
+            }
+        }
 
+        if (status == false)
+        {
+            sprintf(key, "a=cliprect");
+            if (findAttribute(index, key, &value)){
+                char *val = strchr(value.c_str(),',');
+                if (val != NULL) {
+                    val = strchr(++val,',');
+                    *height = atoi(++val);
+                    LOGV("Height = %d",*height);
+                    val = strchr(val,',');
+                    *width = atoi(++val);
+                    LOGV("Width = %d",*width);
+                    status = true;
+                }
+            }
+        }
+        return status;
+    }
     const char *s = value.c_str();
     char *end;
     *width = strtoul(s, &end, 10);
@@ -333,7 +369,7 @@ bool ASessionDescription::parseNTPRange(
         return false;
     }
 
-    return *npt2 > *npt1;
+    return *npt2 >= *npt1;
 }
 
 }  // namespace android
diff --git a/media/libstagefright/rtsp/MyHandler.h b/media/libstagefright/rtsp/MyHandler.h
index efa4fcb..631d385 100644
--- a/media/libstagefright/rtsp/MyHandler.h
+++ b/media/libstagefright/rtsp/MyHandler.h
@@ -21,6 +21,7 @@
 //#define LOG_NDEBUG 0
 #define LOG_TAG "MyHandler"
 #include <utils/Log.h>
+#include <utils/List.h>
 
 #include "APacketSource.h"
 #include "ARTPConnection.h"
@@ -136,6 +137,7 @@ struct MyHandler : public AHandler {
           mReceivedFirstRTPPacket(false),
           mSeekable(false),
           mPlayRequestSent(false),
+          mPaused(false),
           mKeepAliveTimeoutUs(kDefaultKeepAliveTimeoutUs),
           mKeepAliveGeneration(0) {
         mNetLooper->setName("rtsp net");
@@ -180,9 +182,21 @@ struct MyHandler : public AHandler {
     }
 
     void seek(int64_t timeUs) {
-        sp<AMessage> msg = new AMessage('seek', id());
-        msg->setInt64("time", timeUs);
-        msg->post();
+        if (!mSeekPending) {
+            sp<AMessage> msg = new AMessage('seek', id());
+            msg->setInt64("time", timeUs);
+            msg->post();
+        } else {
+            mSeekPoints.push_back(timeUs);
+        }
+    }
+
+    void pause() {
+        (new AMessage('paus', id()))->post();
+    }
+
+    void resume() {
+        (new AMessage('resu', id()))->post();
     }
 
     static void addRR(const sp<ABuffer> &buf) {
@@ -739,6 +753,7 @@ struct MyHandler : public AHandler {
                 mReceivedFirstRTPPacket = false;
                 mSeekable = false;
                 mPlayRequestSent = false;
+                mPaused = false;
 
                 sp<AMessage> reply = new AMessage('tear', id());
 
@@ -889,6 +904,110 @@ struct MyHandler : public AHandler {
                 break;
             }
 
+            case 'paus':
+            {
+                if (!mSeekable) {
+                    LOGW("Cannot pause live stream...");
+                    break;
+                }
+
+                if (mPaused) {
+                    LOGW("Already paused...");
+                    break;
+                }
+
+                mCheckPending = true;
+                ++mCheckGeneration;
+
+                AString request = "PAUSE ";
+                request.append(mSessionURL);
+                request.append(" RTSP/1.0\r\n");
+
+                request.append("Session: ");
+                request.append(mSessionID);
+                request.append("\r\n");
+
+                request.append("\r\n");
+
+                sp<AMessage> reply = new AMessage('pdon', id());
+                mConn->sendRequest(request.c_str(), reply);
+                break;
+            }
+
+            case 'pdon':
+            {
+                int32_t result;
+                CHECK(msg->findInt32("result", &result));
+
+                LOGI("PAUSE completed with result %d (%s)",
+                     result, strerror(-result));
+
+                if (result == OK) {
+                    mPaused = true;
+                }
+                break;
+            }
+
+            case 'resu':
+            {
+                if (!mSeekable || !mPaused) {
+                    LOGW("Session not paused...");
+                    break;
+                }
+
+                AString request = "PLAY ";
+                request.append(mSessionURL);
+                request.append(" RTSP/1.0\r\n");
+
+                request.append("Session: ");
+                request.append(mSessionID);
+                request.append("\r\n");
+
+                request.append("\r\n");
+
+                sp<AMessage> reply = new AMessage('pcom', id());
+                mConn->sendRequest(request.c_str(), reply);
+                break;
+            }
+
+            case 'pcom':
+            {
+                int32_t result;
+                CHECK(msg->findInt32("result", &result));
+
+                LOGI("PLAY completed with result %d (%s)",
+                     result, strerror(-result));
+
+                mCheckPending = false;
+                mPaused = false;
+                postAccessUnitTimeoutCheck();
+
+                if (result == OK) {
+                    sp<RefBase> obj;
+                    CHECK(msg->findObject("response", &obj));
+                    sp<ARTSPResponse> response =
+                        static_cast<ARTSPResponse *>(obj.get());
+
+                    if (response->mStatusCode != 200) {
+                        result = UNKNOWN_ERROR;
+                    } else {
+                        parsePlayResponse(response);
+
+                        ssize_t i = response->mHeaders.indexOfKey("rtp-info");
+                        CHECK_GE(i, 0);
+
+                        LOGV("rtp-info: %s", response->mHeaders.valueAt(i).c_str());
+                    }
+                }
+
+                if (result != OK) {
+                    LOGE("PLAY failed, aborting...");
+                    (new AMessage('abor', id()))->post();
+                }
+
+                break;
+            }
+
             case 'seek':
             {
                 if (!mSeekable) {
@@ -935,6 +1054,7 @@ struct MyHandler : public AHandler {
                     postQueueSeekDiscontinuity(i);
 
                     info->mRTPAnchor = 0;
+                    info->mRTPAnchorBase = 0;
                     info->mNTPAnchorUs = -1;
                 }
 
@@ -974,6 +1094,7 @@ struct MyHandler : public AHandler {
                      result, strerror(-result));
 
                 mCheckPending = false;
+                mPaused = false;
                 postAccessUnitTimeoutCheck();
 
                 if (result == OK) {
@@ -1006,6 +1127,15 @@ struct MyHandler : public AHandler {
                 sp<AMessage> msg = mNotify->dup();
                 msg->setInt32("what", kWhatSeekDone);
                 msg->post();
+
+                if (!mSeekPoints.empty() && result == OK) {
+                    const int64_t timeUs = *mSeekPoints.begin();
+                    mSeekPoints.erase(mSeekPoints.begin());
+                    sp<AMessage> msg = new AMessage('seek', id());
+                    msg->setInt64("time", timeUs);
+                    msg->post();
+                }
+
                 break;
             }
 
@@ -1208,6 +1338,7 @@ private:
         bool mNewSegment;
 
         uint32_t mRTPAnchor;
+        uint32_t mRTPAnchorBase;
         int64_t mNTPAnchorUs;
         int32_t mTimeScale;
 
@@ -1235,6 +1366,7 @@ private:
     AString mSessionID;
     bool mSetupTracksSuccessful;
     bool mSeekPending;
+    List<int64_t> mSeekPoints;
     bool mFirstAccessUnit;
 
     bool mAllTracksHaveTime;
@@ -1252,6 +1384,7 @@ private:
     bool mReceivedFirstRTPPacket;
     bool mSeekable;
     bool mPlayRequestSent;
+    bool mPaused;
     int64_t mKeepAliveTimeoutUs;
     int32_t mKeepAliveGeneration;
 
@@ -1285,6 +1418,7 @@ private:
         info->mFirstSeqNumInSegment = 0;
         info->mNewSegment = true;
         info->mRTPAnchor = 0;
+        info->mRTPAnchorBase = 0;
         info->mNTPAnchorUs = -1;
         info->mNormalPlayTimeRTP = 0;
         info->mNormalPlayTimeUs = 0ll;
@@ -1469,14 +1603,18 @@ private:
     }
 
     bool addMediaTimestamp(
-            int32_t trackIndex, const TrackInfo *track,
+            int32_t trackIndex, TrackInfo *track,
             const sp<ABuffer> &accessUnit) {
         uint32_t rtpTime;
         CHECK(accessUnit->meta()->findInt32(
                     "rtp-time", (int32_t *)&rtpTime));
 
+        if ((track->mRTPAnchor > rtpTime) && (track->mRTPAnchorBase == 0)) {
+            track->mRTPAnchorBase = track->mRTPAnchor;
+        }
+
         int64_t relRtpTimeUs =
-            (((int64_t)rtpTime - (int64_t)track->mRTPAnchor) * 1000000ll)
+            (((int64_t)rtpTime - (int64_t)(track->mRTPAnchor - track->mRTPAnchorBase)) * 1000000ll)
                 / track->mTimeScale;
 
         int64_t ntpTimeUs = track->mNTPAnchorUs + relRtpTimeUs;
-- 
1.7.1

