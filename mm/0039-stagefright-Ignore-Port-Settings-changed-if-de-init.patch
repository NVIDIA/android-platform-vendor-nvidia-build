From cdb4feab47c43e8da4861ec1e33ecf2dcc21f4cf Mon Sep 17 00:00:00 2001
From: Aniruddha C <aniruddhac@nvidia.com>
Date: Wed, 5 Sep 2012 14:28:10 +0530
Subject: [PATCH 39/40] stagefright: Ignore Port Settings changed if de-init

If we are de-initializing and port settings changed event
has arrived, then ignore it.

Bug 1039166

Reviewed on http://git-master/r/#change,129619
(cherry-picked from 5bcadd181f360ceaf22ad2807888ac4a3014d562)

Change-Id: I891132704aca21d33662bd4b8f06e216c8b9aef8

stagefright: reset the variable mNoMoreOutputData before seek

Set the mNoMoreOutputData variable value to false before seek operation.
This will ensure that output buffer will be sent to decoder if
first input buffer contains EOS flag.

Original author: Yogesh Agrawal <yagrawal@nvidia.com>

Bug 923130
Reviewed-on: http://git-master/r/75709

stagefright: Added YUV422Planar to RGB565 color conversion routine

Added routine to convert the color format from YUV422Planar to RGB565
in stagefright color conversion util, required for thumbnail generation.

Original Author: Yogesh Agrawal <yagrawal@nvidia.com>

Bug 912942
Reviewed-on: http://git-master/r/71627

stagefright: fix colorconverter crash for YUV422 format

Bug 872130
Reviewed-on: http://git-master/r/72123

libstagefright:added support for mjpeg with pcm content

Added the necessary mime type to support mjpeg with pcm content.

original author: Vikash<vgarodia@nvidia.com>

bug 837704,
bug 896676
Reviewed on http://git-master/r/#change,40190

Change-Id: I0ea16296aefdc5c9d8b43b7fa6565b99eb29bd32
---
 include/media/stagefright/ColorConverter.h         |    3 +
 media/libstagefright/OMXCodec.cpp                  |    8 ++-
 .../colorconversion/ColorConverter.cpp             |   99 +++++++++++++++++++-
 3 files changed, 107 insertions(+), 3 deletions(-)

diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index 85ba920..09a5819 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -79,6 +79,9 @@ private:
     status_t convertTIYUV420PackedSemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
+    status_t convertYUV422Planar(
+            const BitmapParams &src, const BitmapParams &dst);
+
     ColorConverter(const ColorConverter &);
     ColorConverter &operator=(const ColorConverter &);
 };
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 4b2c4e8..4d5464b 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -823,6 +823,8 @@ void OMXCodec::setVideoInputFormat(
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MJPEG, mime)) {
+        compressionFormat = OMX_VIDEO_CodingMJPEG;
     } else {
         ALOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -1456,6 +1458,8 @@ void OMXCodec::setComponentRole(
             "audio_decoder.raw", "audio_encoder.raw" },
         { MEDIA_MIMETYPE_AUDIO_FLAC,
             "audio_decoder.flac", "audio_encoder.flac" },
+        { MEDIA_MIMETYPE_VIDEO_MJPEG,
+            "video_decoder.jpeg", "video_encoder.jpeg" },
     };
 
     static const size_t kNumMimeToRole =
@@ -2888,7 +2892,8 @@ void OMXCodec::onPortSettingsChanged(OMX_U32 portIndex) {
     CODEC_LOGV("PORT_SETTINGS_CHANGED(%ld)", portIndex);
 
     // In case we have already got ERROR, do not proceed
-    if (mState == ERROR)
+    // If we are de-initializing, ignore port settings changed
+    if ((mState == ERROR) || (mState == EXECUTING_TO_IDLE))
         return;
 
     if((mBuffersWithRenderer == 1) && (mPortSettingsEvent & PORT_SETTINGS_DELAYED)) {
@@ -3968,6 +3973,7 @@ status_t OMXCodec::read(
     ReadOptions::SeekMode seekMode;
     if (options && options->getSeekTo(&seekTimeUs, &seekMode)) {
         seeking = true;
+        mNoMoreOutputData = false;
     }
 
     if (mInitialBufferSubmit) {
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 597167f..8575d3f 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -47,6 +47,7 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+        case OMX_COLOR_FormatYUV422Planar:
             return true;
 
         default:
@@ -122,6 +123,10 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
+        case OMX_COLOR_FormatYUV422Planar:
+            err = convertYUV422Planar(src, dst);
+            break;
+
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
@@ -132,6 +137,96 @@ status_t ColorConverter::convert(
     return err;
 }
 
+status_t ColorConverter::convertYUV422Planar(
+        const BitmapParams &src, const BitmapParams &dst) {
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+   uint32_t *dst_ptr = (uint32_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_y =
+        (const uint8_t *)src.mBits + src.mCropTop * src.mWidth + src.mCropLeft;
+
+    const uint8_t *src_u =
+        (const uint8_t *)src.mBits + src.mWidth * src.mHeight
+        + src.mCropTop * (src.mWidth / 2) + src.mCropLeft / 2;
+
+    const uint8_t *src_v =
+        src_u + (src.mWidth / 2) * src.mHeight;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+            // B = 1.164 * (Y - 16) + 2.018 * (U - 128)
+            // G = 1.164 * (Y - 16) - 0.813 * (V - 128) - 0.391 * (U - 128)
+            // R = 1.164 * (Y - 16) + 1.596 * (V - 128)
+
+            // B = 298/256 * (Y - 16) + 517/256 * (U - 128)
+            // G = .................. - 208/256 * (V - 128) - 100/256 * (U - 128)
+            // R = .................. + 409/256 * (V - 128)
+
+            // min_B = (298 * (- 16) + 517 * (- 128)) / 256 = -277
+            // min_G = (298 * (- 16) - 208 * (255 - 128) - 100 * (255 - 128)) / 256 = -172
+            // min_R = (298 * (- 16) + 409 * (- 128)) / 256 = -223
+
+            // max_B = (298 * (255 - 16) + 517 * (255 - 128)) / 256 = 534
+            // max_G = (298 * (255 - 16) - 208 * (- 128) - 100 * (- 128)) / 256 = 432
+            // max_R = (298 * (255 - 16) + 409 * (255 - 128)) / 256 = 481
+
+            // clip range -278 .. 535
+
+            signed y1 = (signed)src_y[x] - 16;
+            signed y2 = (signed)src_y[x + 1] - 16;
+
+            signed u = (signed)src_u[x / 2] - 128;
+            signed v = (signed)src_v[x / 2] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            dst_ptr[x / 2] = (rgb2 << 16) | rgb1;
+        }
+
+        src_y += src.mWidth;
+        src_u += src.mWidth / 2;
+        src_v += src.mWidth / 2;
+
+        dst_ptr += dst.mWidth / 2;
+    }
+
+    return OK;
+}
+
+
 status_t ColorConverter::convertCbYCrY(
         const BitmapParams &src, const BitmapParams &dst) {
     // XXX Untested
@@ -213,8 +308,8 @@ status_t ColorConverter::convertYUV420Planar(
         (const uint8_t *)src.mBits + src.mCropTop * src.mWidth + src.mCropLeft;
 
     const uint8_t *src_u =
-        (const uint8_t *)src_y + src.mWidth * src.mHeight
-        + src.mCropTop * (src.mWidth / 2) + src.mCropLeft / 2;
+        (const uint8_t *)src.mBits + src.mWidth * src.mHeight
+        + (src.mCropTop / 2) * (src.mWidth / 2) + src.mCropLeft / 2;
 
     const uint8_t *src_v =
         src_u + (src.mWidth / 2) * (src.mHeight / 2);
-- 
1.7.1

