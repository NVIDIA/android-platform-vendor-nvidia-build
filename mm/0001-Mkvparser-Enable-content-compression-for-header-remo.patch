From fd7887e1f59df24dc612b1a3612c3fe2e0dc7d07 Mon Sep 17 00:00:00 2001
From: Yogesh Solanke <ysolanke@nvidia.com>
Date: Wed, 20 Jun 2012 18:17:21 +0530
Subject: [PATCH] Mkvparser: Enable content compression for header removal

-Parse Content compression
-Add support for header removal algorithm
-Append removed header to each frame begining

Bug 991847

Partial integration from commit:
http://git-master/r/#change,62633
 original bug: 896763

Change-Id: Iaa74315cc293178092cf133703a65a26bdd0136f
Reviewed-on: http://git-psac/r/289
Reviewed-by: Yogesh Solanke <ysolanke@nvidia.com>
Tested-by: Yogesh Solanke <ysolanke@nvidia.com>
Reviewed-by: Zhijun He <zhhe@nvidia.com>

mkvparser: Error handling for content encoding

Some time may have checking content encoding for tracks
which is not parse like text. Add error handling to avoid
crash due to tracks unavailable for conent encoding.

Bug 1022434

Change-Id: Id1ee5dc31aa04809e00372898fb273fc4ac8a648
---
 mkvparser/mkvparser.cpp |  144 ++++++++++++++++++++++++++++++++++++++++++-----
 mkvparser/mkvparser.hpp |   20 ++++++-
 2 files changed, 146 insertions(+), 18 deletions(-)

diff --git a/mkvparser/mkvparser.cpp b/mkvparser/mkvparser.cpp
index e48343f..4d21944 100644
--- a/mkvparser/mkvparser.cpp
+++ b/mkvparser/mkvparser.cpp
@@ -5,6 +5,9 @@
 // tree. An additional intellectual property rights grant can be found
 // in the file PATENTS.  All contributing project authors may
 // be found in the AUTHORS file in the root of the source tree.
+//#define LOG_NDEBUG 0
+#define LOG_TAG "mkvparser"
+#include <utils/Log.h>
 
 #include "mkvparser.hpp"
 #include <cassert>
@@ -3450,6 +3453,7 @@ const Cluster* Segment::GetNext(const Cluster* pCurr)
 }
 
 
+
 long Segment::ParseNext(
     const Cluster* pCurr,
     const Cluster*& pResult,
@@ -4384,7 +4388,8 @@ const char* SegmentInfo::GetTitleAsUTF8() const
 // ContentEncoding element
 ContentEncoding::ContentCompression::ContentCompression()
     : algo(0),
-      settings(NULL) {
+      settings(NULL),
+      size(0) {
 }
 
 ContentEncoding::ContentCompression::~ContentCompression() {
@@ -4460,6 +4465,48 @@ unsigned long ContentEncoding::GetCompressionCount() const {
   return static_cast<unsigned long>(count);
 }
 
+void ContentEncoding::ParseCompressionEntry(long long start,
+      long long size,
+      IMkvReader* const pReader,
+      ContentCompression* const compression) {
+  assert(pReader);
+  assert(compression);
+  long long pos = start;
+  const long long stop = start + size;
+
+  long long value;
+  unsigned char* buf;
+  size_t buf_len;
+  while (pos < stop) {
+    if (Match(pReader, pos, 0x254, value)) {
+      // Compression Algo
+      compression->algo = value;
+    } else if (Match(pReader, pos, 0x255, buf, buf_len)) {
+      // Compression data
+      compression->settings = buf;
+      compression->size = buf_len;
+    } else
+    {
+        long len;
+        const long long id = ReadUInt(pReader, pos, len);
+        assert(id >= 0);  //TODO: handle error case
+        assert((pos + len) <= stop);
+
+        pos += len;  //consume id
+
+        const long long size = ReadUInt(pReader, pos, len);
+        assert(size >= 0);  //TODO: handle error case
+        assert((pos + len) <= stop);
+
+        pos += len;  //consume length of size
+        const long long start = pos;
+
+        pos += size;  //consume payload
+        assert(pos <= stop);
+    }
+  }
+}
+
 const ContentEncoding::ContentEncryption*
 ContentEncoding::GetEncryptionByIndex(unsigned long idx) const {
   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;
@@ -4550,7 +4597,6 @@ bool ContentEncoding::ParseContentEncodingEntry(long long start,
 
   long long pos = start;
   const long long stop = start + size;
-
   // Count ContentCompression and ContentEncryption elements.
   long long pos1 = start;
   int compression_count = 0;
@@ -4583,7 +4629,6 @@ bool ContentEncoding::ParseContentEncodingEntry(long long start,
 
   if (compression_count <= 0 && encryption_count <= 0)
     return false;
-
   if (compression_count > 0) {
     compression_entries_ = new ContentCompression*[compression_count];
     compression_entries_end_ = compression_entries_;
@@ -4632,7 +4677,10 @@ bool ContentEncoding::ParseContentEncodingEntry(long long start,
 
       if (id == 0x1034) {
         // ContentCompression ID
-        // TODO(fgaligan): Add code to parse ContentCompression elements.
+        ContentCompression* const compression = new ContentCompression();
+        ParseCompressionEntry(pos,size,pReader, compression);
+        *compression_entries_end_ = compression;
+        ++compression_entries_end_;
       } else if (id == 0x1035) {
         // ContentEncryption ID
         ContentEncryption* const encryption = new ContentEncryption();
@@ -4839,7 +4887,6 @@ bool Track::GetLacing() const
 long Track::GetFirst(const BlockEntry*& pBlockEntry) const
 {
     const Cluster* pCluster = m_pSegment->GetFirst();
-
     for (int i = 0; ; )
     {
         if (pCluster == NULL)
@@ -5244,7 +5291,6 @@ bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const
     return pBlock->IsKey();
 }
 
-
 long VideoTrack::Seek(
     long long time_ns,
     const BlockEntry*& pResult) const
@@ -5478,7 +5524,6 @@ bool AudioTrack::VetEntry(const BlockEntry* pBlockEntry) const
     return true;
 }
 
-
 long AudioTrack::Seek(
     long long time_ns,
     const BlockEntry*& pResult) const
@@ -5652,6 +5697,7 @@ long Tracks::Parse()
 
         long long id, payload_size;
 
+
         const long status = ParseElementHeader(
                                 pReader,
                                 pos,
@@ -8081,7 +8127,7 @@ SimpleBlock::SimpleBlock(
 
 long SimpleBlock::Parse()
 {
-    return m_block.Parse(m_pCluster->m_pSegment->m_pReader);
+    return m_block.Parse(m_pCluster->m_pSegment);
 }
 
 
@@ -8116,7 +8162,7 @@ BlockGroup::BlockGroup(
 
 long BlockGroup::Parse()
 {
-    const long status = m_block.Parse(m_pCluster->m_pSegment->m_pReader);
+    const long status = m_block.Parse(m_pCluster->m_pSegment);
 
     if (status)
         return status;
@@ -8175,7 +8221,9 @@ Block::Block(long long start, long long size_) :
     m_timecode(-1),
     m_flags(0),
     m_frames(NULL),
-    m_frame_count(-1)
+    m_frame_count(-1),
+    mByteStrip(0),
+    m_pSetting(NULL)
 {
 }
 
@@ -8186,9 +8234,10 @@ Block::~Block()
 }
 
 
-long Block::Parse(IMkvReader* pReader)
+long Block::Parse(Segment* pSegment)
 {
-    assert(pReader);
+    assert(pSegment);
+    IMkvReader* pReader = pSegment->m_pReader;
     assert(m_start >= 0);
     assert(m_size >= 0);
     assert(m_track <= 0);
@@ -8213,6 +8262,8 @@ long Block::Parse(IMkvReader* pReader)
     if ((stop - pos) < 2)
         return E_FILE_FORMAT_INVALID;
 
+    SetComp(pSegment);
+
     long status;
     long long value;
 
@@ -8243,6 +8294,7 @@ long Block::Parse(IMkvReader* pReader)
 
     ++pos;  //consume flags byte
 
+
     if (lacing == 0)  //no lacing
     {
         if (pos > stop)
@@ -8260,6 +8312,14 @@ long Block::Parse(IMkvReader* pReader)
             return E_FILE_FORMAT_INVALID;
 
         f.len = static_cast<long>(frame_size);
+        if (mByteStrip > 0) {
+            f.len += mByteStrip;
+            f.byteStrip = mByteStrip;
+            f.pSetting = m_pSetting;
+        } else {
+            f.byteStrip = 0;
+            f.pSetting = NULL;
+        }
 
         return 0;  //success
     }
@@ -8357,6 +8417,14 @@ long Block::Parse(IMkvReader* pReader)
 
             f.pos = pos;
             pos += f.len;
+            if (mByteStrip > 0) {
+                f.len += mByteStrip;
+                f.byteStrip = mByteStrip;
+                f.pSetting = m_pSetting;
+            } else {
+                f.byteStrip = 0;
+                f.pSetting = NULL;
+            }
         }
 
         assert(pos == stop);
@@ -8385,6 +8453,15 @@ long Block::Parse(IMkvReader* pReader)
             f.pos = pos;
             f.len = static_cast<long>(frame_size);
 
+            if (mByteStrip > 0) {
+                f.len += mByteStrip;
+                f.byteStrip = mByteStrip;
+                f.pSetting = m_pSetting;
+            } else {
+                f.byteStrip = 0;
+                f.pSetting = NULL;
+            }
+
             pos += frame_size;
         }
 
@@ -8510,6 +8587,14 @@ long Block::Parse(IMkvReader* pReader)
 
             f.pos = pos;
             pos += f.len;
+            if (mByteStrip > 0) {
+                f.len += mByteStrip;
+                f.byteStrip = mByteStrip;
+                f.pSetting = m_pSetting;
+            } else {
+                f.byteStrip = 0;
+                f.pSetting = NULL;
+            }
         }
 
         assert(pos == stop);
@@ -8573,6 +8658,29 @@ void Block::SetKey(bool bKey)
         m_flags &= 0x7F;
 }
 
+void Block::SetComp(Segment* pSegment)
+{
+
+    const Tracks* pts = pSegment->GetTracks();
+    const Track* pt =  pts->GetTrackByNumber(m_track);
+    if (pt == NULL)
+        return;
+    unsigned long idx = pt->GetContentEncodingCount();
+
+    if(idx > 0) {
+        const ContentEncoding* ContEnc = pt->GetContentEncodingByIndex(idx-1);
+        idx = ContEnc->GetCompressionCount();
+
+        if(idx > 0) {
+            const ContentEncoding::ContentCompression* ContComp = ContEnc->GetCompressionByIndex(idx-1);
+
+            if(ContComp->algo == mkvparser::CONTENT_HEADER_STRIPPING) {
+                mByteStrip = ContComp->size;
+                m_pSetting = ContComp->settings;
+            }
+        }
+    }
+}
 
 bool Block::IsInvisible() const
 {
@@ -8610,9 +8718,15 @@ long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const
 {
     assert(pReader);
     assert(buf);
-
-    const long status = pReader->Read(pos, len, buf);
-    return status;
+    if(byteStrip > 0)
+    {
+        const long status = pReader->Read(pos, (len-byteStrip), (buf+byteStrip));
+        memcpy(buf,pSetting,byteStrip);
+        return status;
+    } else {
+        const long status = pReader->Read(pos, len, buf);
+        return status;
+    }
 }
 
 
diff --git a/mkvparser/mkvparser.hpp b/mkvparser/mkvparser.hpp
index 7e4abec..a3ddca4 100644
--- a/mkvparser/mkvparser.hpp
+++ b/mkvparser/mkvparser.hpp
@@ -18,6 +18,7 @@ namespace mkvparser
 
 const int E_FILE_FORMAT_INVALID = -2;
 const int E_BUFFER_NOT_FULL = -3;
+const int CONTENT_HEADER_STRIPPING = 3;
 
 class IMkvReader
 {
@@ -86,7 +87,7 @@ public:
     Block(long long start, long long size);
     ~Block();
 
-    long Parse(IMkvReader*);
+    long Parse(Segment*);
 
     long long GetTrackNumber() const;
     long long GetTimeCode(const Cluster*) const;  //absolute, but not scaled
@@ -94,7 +95,7 @@ public:
     bool IsKey() const;
     void SetKey(bool);
     bool IsInvisible() const;
-
+    void SetComp(Segment*);
     enum Lacing { kLacingNone, kLacingXiph, kLacingFixed, kLacingEbml };
     Lacing GetLacing() const;
 
@@ -104,7 +105,8 @@ public:
     {
         long long pos;  //absolute offset
         long len;
-
+        unsigned long byteStrip;
+        unsigned char* pSetting;
         long Read(IMkvReader*, unsigned char*) const;
     };
 
@@ -114,6 +116,8 @@ private:
     long long m_track;   //Track::Number()
     short m_timecode;  //relative to cluster
     unsigned char m_flags;
+    unsigned long mByteStrip;
+    unsigned char* m_pSetting;
 
     Frame* m_frames;
     int m_frame_count;
@@ -213,6 +217,7 @@ public:
 
         unsigned long long algo;
         unsigned char* settings;
+        unsigned long size;
     };
 
     // ContentEncryption element names
@@ -263,6 +268,15 @@ public:
                               IMkvReader* const pReader,
                               ContentEncryption* const encryption);
 
+    // Parses the ContentCompression element from |pReader|. |start| is the
+    // starting offset of the ContentCompression payload. |size| is the size in
+    // bytes of the ContentCompression payload. |compression| is where the parsed
+    // values will be stored.
+    void ParseCompressionEntry(long long start,
+                              long long size,
+                              IMkvReader* const pReader,
+                              ContentCompression* const compression);
+
     unsigned long long encoding_order() const { return encoding_order_; }
     unsigned long long encoding_scope() const { return encoding_scope_; }
     unsigned long long encoding_type() const { return encoding_type_; }
-- 
1.7.1

