From 92f2e8ccadce2a89d5af740d62f5b6058a0d87ed Mon Sep 17 00:00:00 2001
From: Dara Ramesh <dramesh@nvidia.com>
Date: Mon, 27 Aug 2012 12:42:26 +0530
Subject: [PATCH 4/5] support AC3/DTS pass-through in JB

- Use bypass decoder for AC3 streams. Bypass decoder gives out
silence when HW AC3 decode support is unavailable.
- Reopen AudioSink on resume for compressed audio
- Set sample size to 2 for IEC61937 format
- Fix glitch during pause/resume of AC3 stream

Bug 998699

Integrations for following commits:
http://git-master/r/84921
http://git-master/r/84922
http://git-master/r/84923
http://git-master/r/93787
http://git-master/r/82662
http://git-master/r/145931

Change-Id: I2b745ed3e1e641fa5328b7fe5255c4d184a8e224
---
 include/media/stagefright/OMXCodec.h   |    1 +
 media/libmedia/AudioTrack.cpp          |    2 +-
 media/libstagefright/AudioPlayer.cpp   |   52 +++++++++++++-----
 media/libstagefright/OMXCodec.cpp      |   91 ++++++++++++++++++++++++++++++++
 services/audioflinger/AudioFlinger.cpp |    8 +++-
 5 files changed, 137 insertions(+), 17 deletions(-)

diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index 747074b..14d4c17 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -222,6 +222,7 @@ private:
     Condition mAsyncCompletion;
 
     bool mPaused;
+    bool mHwAudioDec;
     bool mErrWhileRecon;
     bool mIsMvc;
 
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 24b9e9a..baf4bc8 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -356,7 +356,7 @@ uint32_t AudioTrack::frameCount() const
 
 size_t AudioTrack::frameSize() const
 {
-    if (audio_is_linear_pcm(mFormat)) {
+    if (audio_is_linear_pcm(mFormat) || (AUDIO_FORMAT_IEC61937 == mFormat)) {
         return channelCount()*audio_bytes_per_sample(mFormat);
     } else {
         return sizeof(uint8_t);
diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index 86e7043..50a33ff 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -192,6 +192,11 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
         // sending compressed audio as it is
         CHECK(numChannels == 2);
         mAudioFormat = AUDIO_FORMAT_AAC;
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3) ||
+        !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_DTS)) {
+         // sending compressed audio in IEC61937 format
+         CHECK(numChannels == 2);
+         mAudioFormat = AUDIO_FORMAT_IEC61937;
     } else {
         int32_t bitsPerSample;
         if (format->findInt32(kKeyBitsPerSample, &bitsPerSample)) {
@@ -279,7 +284,11 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
 void AudioPlayer::pause(bool playPendingSamples) {
     CHECK(mStarted);
 
-    if ((playPendingSamples) && (mEnabledAudioULP == false)) {
+    // If HDMI receiver is removed in pause state while sending compressed
+    // data, flush pending data to avoid playback of buffered compressed
+    // frames as PCM
+    if ((playPendingSamples || (mAudioFormat != AUDIO_FORMAT_PCM_16_BIT)) &&
+        (mEnabledAudioULP == false)) {
         if (mAudioSink.get() != NULL) {
             mAudioSink->stop();
         } else {
@@ -309,17 +318,27 @@ void AudioPlayer::pause(bool playPendingSamples) {
 void AudioPlayer::resume() {
     CHECK(mStarted);
 
-    if(mEnabledAudioULP) {
-        String8 key = String8("nv_param_avp_decode_pause=0");
-        AudioSystem::setParameters(0,key);
-        if (mReachedEOS)
-            mULP_ResumeOnEOS = true;
-    }
+    if ((audio_is_linear_pcm(mAudioFormat)) || mEnabledAudioULP) {
+        if(mEnabledAudioULP) {
+            String8 key = String8("nv_param_avp_decode_pause=0");
+            AudioSystem::setParameters(0,key);
+            if (mReachedEOS)
+                mULP_ResumeOnEOS = true;
+        }
 
-    if (mAudioSink.get() != NULL) {
-        mAudioSink->start();
+        if (mAudioSink.get() != NULL) {
+            mAudioSink->start();
+        } else {
+            mAudioTrack->start();
+        }
     } else {
-        mAudioTrack->start();
+        // compressed audio case
+        // HDMI receiver could have been removed (or plugged out and plugged in).
+        // So the AUX stream might not be in proper state required for
+        // compressed.audio pass-thru.
+        // Reopen AudioTrack to handle this scenario
+        mPortSettingsChangedEventPending = true;
+        mQueue.postEvent(mPortSettingsChangedEvent);
     }
 }
 
@@ -474,7 +493,6 @@ void AudioPlayer::onPortSettingsChangedEvent() {
     const char *mime;
     success = format->findCString(kKeyMIMEType, &mime);
     CHECK(success);
-    CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)); //need to check
 
     success = format->findInt32(kKeySampleRate, &mSampleRate);
     CHECK(success);
@@ -501,8 +519,6 @@ void AudioPlayer::onPortSettingsChangedEvent() {
         channelMask = CHANNEL_MASK_USE_CHANNEL_ORDER;
     }
 
-    ALOGV("New sample rate %d channels %d", mSampleRate, numChannels);
-
     if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG) ||
         !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II)) {
         // sending compressed audio as it is
@@ -512,6 +528,11 @@ void AudioPlayer::onPortSettingsChangedEvent() {
         // sending compressed audio as it is
         CHECK(numChannels == 2);
         mAudioFormat = AUDIO_FORMAT_AAC;
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3) ||
+               !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_DTS)) {
+        // sending compressed audio in IEC61937 format
+        CHECK(numChannels == 2);
+        mAudioFormat = AUDIO_FORMAT_IEC61937;
     } else {
         int32_t bitsPerSample;
         if (format->findInt32(kKeyBitsPerSample, &bitsPerSample)) {
@@ -529,10 +550,11 @@ void AudioPlayer::onPortSettingsChangedEvent() {
         }
     }
 
+    ALOGV("New sample rate %d channels %d format: 0x%x", mSampleRate, numChannels, mAudioFormat);
 
     if (mAudioSink.get() != NULL) {
         err = mAudioSink->open(
-                 mSampleRate, numChannels, channelMask, AUDIO_FORMAT_PCM_16_BIT,
+                 mSampleRate, numChannels, channelMask, mAudioFormat,
                  DEFAULT_AUDIOSINK_BUFFERCOUNT,
                  &AudioPlayer::AudioSinkCallback,
                  this,
@@ -558,7 +580,7 @@ void AudioPlayer::onPortSettingsChangedEvent() {
         }
 
         mAudioTrack = new AudioTrack(
-                   AUDIO_STREAM_MUSIC, mSampleRate, AUDIO_FORMAT_PCM_16_BIT, audioMask,
+                   AUDIO_STREAM_MUSIC, mSampleRate, mAudioFormat, audioMask,
                    0, AUDIO_OUTPUT_FLAG_NONE, &AudioCallback, this, 0);
 
         if ((err = mAudioTrack->initCheck()) != OK) {
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index b96b4ae..443f1be 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -38,6 +38,7 @@
 #include <media/stagefright/Utils.h>
 #include <media/stagefright/SkipCutBuffer.h>
 #include <utils/Vector.h>
+#include <cutils/properties.h>
 
 #include <OMX_Audio.h>
 #include <OMX_Component.h>
@@ -1428,6 +1429,7 @@ OMXCodec::OMXCodec(
       mPaused(false),
       mErrWhileRecon(false),
       mIsMvc(false),
+      mHwAudioDec(0),
       mNativeWindow(
               (!strncmp(componentName, "OMX.google.", 11))
                         ? NULL : nativeWindow) {
@@ -1462,6 +1464,10 @@ void OMXCodec::setComponentRole(
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
             "audio_decoder.vorbis", "audio_encoder.vorbis" },
+        { MEDIA_MIMETYPE_AUDIO_AC3,
+            "audio_decoder.ac3", "audio_encoder.ac3" },
+        { MEDIA_MIMETYPE_AUDIO_DTS,
+            "audio_decoder.dts", "audio_encoder.dts" },
         { MEDIA_MIMETYPE_AUDIO_G711_MLAW,
             "audio_decoder.g711mlaw", "audio_encoder.g711mlaw" },
         { MEDIA_MIMETYPE_AUDIO_G711_ALAW,
@@ -4002,6 +4008,43 @@ status_t OMXCodec::read(
         seeking = true;
         mNoMoreOutputData = false;
     }
+    bool isAudioDec = !strncasecmp(mMIME, "audio/", 6) && !mIsEncoder;
+
+    if (isAudioDec) {
+        char value[PROPERTY_VALUE_MAX];
+        if (!strcmp(mComponentName, "OMX.Nvidia.bypass.decoder")) {
+            bool hwAudioDec;
+            memset(value, 0, sizeof(value));
+            if (!strcasecmp(mMIME, "audio/ac3")) {
+                property_get("media.tegra.hw.ac3dec", value, "0");
+            } else if (!strcasecmp(mMIME, "audio/dts")) {
+                property_get("media.tegra.hw.dtsdec", value, "0");
+            }
+
+            hwAudioDec =  (bool)atoi(value);
+
+            if (mHwAudioDec != hwAudioDec) {
+                OMX_INDEXTYPE index;
+                CODEC_LOGI("updating HW Audio Dec capability from %d to %d \n", mHwAudioDec, hwAudioDec);
+                status_t err = mOMX->getExtensionIndex(mNode, NVX_INDEX_CONFIG_SILENCE_OUTPUT, &index);
+                if(err == OK) {
+                    OMX_CONFIG_BOOLEANTYPE silenceOutput;
+                    memset(&silenceOutput, 0, sizeof(silenceOutput));
+                    InitOMXParams(&silenceOutput);
+
+                    // set silence output if HW decode not supported
+                    silenceOutput.bEnabled = hwAudioDec ? OMX_FALSE : OMX_TRUE;
+                    err = mOMX->setConfig(mNode, index, &silenceOutput, sizeof(silenceOutput));
+                    if(err != OK) {
+                        CODEC_LOGE("setConfig silenceOutput failed \n");
+                    }
+                } else {
+                    CODEC_LOGE("%s getindex failed \n", NVX_INDEX_CONFIG_SILENCE_OUTPUT);
+                }
+                mHwAudioDec = hwAudioDec;
+            }
+        }
+    }
 
     if (mInitialBufferSubmit) {
         mInitialBufferSubmit = false;
@@ -4136,6 +4179,16 @@ status_t OMXCodec::read(
     CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
     info->mStatus = OWNED_BY_CLIENT;
 
+    if (!strcmp(mComponentName, "OMX.Nvidia.bypass.decoder")) {
+        // If HDMI receiver was removed in pause state while sending compressed
+        // data, avoid playback of buffered compressed frames as PCM
+        OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *)info->mBuffer;
+        if (!mHwAudioDec && (header->nFlags & OMX_BUFFERFLAG_COMPRESSED)) {
+            CODEC_LOGI("silencing compressed buffer");
+            if (info->mData)
+                memset(info->mData, 0, info->mMediaBuffer->range_length());
+        }
+    }
     info->mMediaBuffer->add_ref();
     if (mSkipCutBuffer != NULL) {
         mSkipCutBuffer->submit(info->mMediaBuffer);
@@ -4676,6 +4729,44 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setInt32(kKeyChannelCount, numChannels);
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
                 mOutputFormat->setInt32(kKeyBitRate, bitRate);
+            } else if (audio_def->eEncoding ==
+                        (OMX_AUDIO_CODINGTYPE)NVX_AUDIO_CodingAC3) {
+                OMX_INDEXTYPE index;
+                NVX_AUDIO_PARAM_AC3TYPE ac3params;
+                InitOMXParams(&ac3params);
+                ac3params.nPortIndex = kPortIndexOutput;
+
+                err = mOMX->getExtensionIndex(mNode, NVX_INDEX_PARAM_AC3, &index);
+                if(err == OK) {
+                    err = mOMX->getParameter(mNode, index, &ac3params, sizeof(ac3params));
+                    CHECK_EQ(err, (status_t)OK);
+
+                    mOutputFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);
+                    mOutputFormat->setInt32(kKeyChannelCount, ac3params.nChannels);
+                    mOutputFormat->setInt32(kKeySampleRate, ac3params.nSampleRate);
+                } else {
+                    CODEC_LOGE("GetExtensionIndex %s failed with error 0x%x\n",
+                            NVX_INDEX_PARAM_AC3, err);
+                }
+            } else if (audio_def->eEncoding ==
+                        (OMX_AUDIO_CODINGTYPE)NVX_AUDIO_CodingDTS) {
+                OMX_INDEXTYPE index;
+                NVX_AUDIO_PARAM_DTSTYPE dtsparams;
+                InitOMXParams(&dtsparams);
+                dtsparams.nPortIndex = kPortIndexOutput;
+
+                err = mOMX->getExtensionIndex(mNode, NVX_INDEX_PARAM_DTS, &index);
+                if(err == OK) {
+                    err = mOMX->getParameter(mNode, index, &dtsparams, sizeof(dtsparams));
+                    CHECK_EQ(err, (status_t)OK);
+
+                    mOutputFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_DTS);
+                    mOutputFormat->setInt32(kKeyChannelCount, dtsparams.nChannels);
+                    mOutputFormat->setInt32(kKeySampleRate, dtsparams.nSampleRate);
+                } else {
+                    CODEC_LOGE("GetExtensionIndex %s failed with error 0x%x\n",
+                            NVX_INDEX_PARAM_DTS, err);
+                }
             } else {
                 CHECK(!"Should not be here. Unknown audio encoding.");
             }
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 6a35053..37ed275 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -4341,7 +4341,13 @@ AudioFlinger::PlaybackThread::Track::Track(
     if (mCblk != NULL) {
         // NOTE: audio_track_cblk_t::frameSize for 8 bit PCM data is based on a sample size of
         // 16 bit because data is converted to 16 bit before being stored in buffer by AudioTrack
-        mCblk->frameSize = audio_is_linear_pcm(format) ? mChannelCount * sizeof(int16_t) : sizeof(uint8_t);
+        // IEC61937 format is sent as 2 channel PCM stream
+        if (audio_is_linear_pcm(format))
+            mCblk->frameSize = mChannelCount * sizeof(int16_t);
+        else if (AUDIO_FORMAT_IEC61937 == format)
+            mCblk->frameSize = sizeof(int16_t);
+        else
+            mCblk->frameSize = sizeof(int8_t);
         // to avoid leaking a track name, do not allocate one unless there is an mCblk
         mName = thread->getTrackName_l(channelMask, sessionId);
         mCblk->mName = mName;
-- 
1.7.1

