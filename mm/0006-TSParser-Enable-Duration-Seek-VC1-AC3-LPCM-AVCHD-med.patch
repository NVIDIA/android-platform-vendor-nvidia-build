From 9683284655a9058bd4eb79a7a956e3908e3ec411 Mon Sep 17 00:00:00 2001
From: Suresh Choudhary <sureshc@nvidia.com>
Date: Mon, 29 Oct 2012 15:07:10 +0530
Subject: [PATCH 06/40] TSParser: Enable Duration/Seek, VC1/AC3/LPCM AVCHD media

1. Adds logic to calculate stream duration for m2ts streams
2. Enables seek support for m2ts/avchd streams.
3. Enables VC1 video and AC3/EAC3/LPCM audio for AVCHD.

This commit constitutes of following commits:

http://git-master/r/#change,74972
http://git-master/r/#change,77275
http://git-master/r/#change,78168
http://git-master/r/#change,79778
http://git-master/r/#change,79773
http://git-master/r/#change,83427
http://git-master/r/#change,84933
http://git-master/r/#change,86924
http://git-master/r/#change,90988

Change-Id: I91acb962141c712930582745c810aaabd5f8c668
Reviewed-on: http://git-psac/r/258
Reviewed-by: Lokesh Pathak <lpathak@nvidia.com>
Tested-by: Lokesh Pathak <lpathak@nvidia.com>

Conflicts:

	media/libstagefright/mpeg2ts/ATSParser.cpp
	media/libstagefright/mpeg2ts/ATSParser.h
---
 media/libstagefright/AudioPlayer.cpp              |    6 +
 media/libstagefright/OMXCodec.cpp                 |    4 +-
 media/libstagefright/include/MPEG2TSExtractor.h   |    5 +
 media/libstagefright/mpeg2ts/ATSParser.cpp        |  174 ++++++-
 media/libstagefright/mpeg2ts/ATSParser.h          |   23 +-
 media/libstagefright/mpeg2ts/ESQueue.cpp          |  579 +++++++++++++++++++--
 media/libstagefright/mpeg2ts/ESQueue.h            |    6 +
 media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp |  134 +++++-
 8 files changed, 865 insertions(+), 66 deletions(-)

diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index 4208019..5a92a34 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -401,6 +401,12 @@ size_t AudioPlayer::fillBuffer(void *data, size_t size) {
                 err = mSource->read(&mInputBuffer, &options);
             }
 
+            // Technically INFO_DICONTINUITY is not an error
+            if (err == INFO_DISCONTINUITY) {
+               // Ignore this error
+               continue;
+            }
+
             CHECK((err == OK && mInputBuffer != NULL)
                    || (err != OK && mInputBuffer == NULL));
 
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index fdeb7fa..14aeefe 100755
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -3037,9 +3037,9 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
             err = mSource->read(&srcBuffer, &options);
 
-            if (err == OK) {
+            if ((err == OK) || (err == INFO_DISCONTINUITY)) {
                 int64_t targetTimeUs;
-                if (srcBuffer->meta_data()->findInt64(
+                if (srcBuffer && srcBuffer->meta_data()->findInt64(
                             kKeyTargetTime, &targetTimeUs)
                         && targetTimeUs >= 0) {
                     CODEC_LOGV("targetTimeUs = %lld us", targetTimeUs);
diff --git a/media/libstagefright/include/MPEG2TSExtractor.h b/media/libstagefright/include/MPEG2TSExtractor.h
index fe74a42..03f04a8 100644
--- a/media/libstagefright/include/MPEG2TSExtractor.h
+++ b/media/libstagefright/include/MPEG2TSExtractor.h
@@ -46,6 +46,8 @@ struct MPEG2TSExtractor : public MediaExtractor {
 
     void setLiveSession(const sp<LiveSession> &liveSession);
     void seekTo(int64_t seekTimeUs);
+    uint64_t GetM2TSDuration();
+    bool IsM2TSMedia(void);
 
 private:
     friend struct MPEG2TSSource;
@@ -60,6 +62,9 @@ private:
     Vector<sp<AnotherPacketSource> > mSourceImpls;
 
     off64_t mOffset;
+    int64_t durationUs;
+    off64_t fileSize;
+    bool isM2TSMedia;
 
     void init();
     status_t feedMore();
diff --git a/media/libstagefright/mpeg2ts/ATSParser.cpp b/media/libstagefright/mpeg2ts/ATSParser.cpp
index 4924a1d..5310de3 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -53,7 +53,7 @@ struct ATSParser::Program : public RefBase {
     bool parsePID(
             unsigned pid, unsigned continuity_counter,
             unsigned payload_unit_start_indicator,
-            ABitReader *br, status_t *err);
+            ABitReader *br, status_t *err, bool onlypts = false);
 
     void signalDiscontinuity(
             DiscontinuityType type, const sp<AMessage> &extra);
@@ -82,6 +82,18 @@ struct ATSParser::Program : public RefBase {
         return mParser->mFlags;
     }
 
+    void setFirstPts(uint64_t PTS) {
+       mParser->setFirstPts(PTS);
+    }
+
+    void setLastPts(uint64_t PTS) {
+       mParser->setLastPts(PTS);
+    }
+
+    void setDurationPID(unsigned pid) {
+       mParser->setDurationPID(pid);
+    }
+
 private:
     ATSParser *mParser;
     unsigned mProgramNumber;
@@ -110,7 +122,7 @@ struct ATSParser::Stream : public RefBase {
     status_t parse(
             unsigned continuity_counter,
             unsigned payload_unit_start_indicator,
-            ABitReader *br);
+            ABitReader *br, bool onlypts = false);
 
     void signalDiscontinuity(
             DiscontinuityType type, const sp<AMessage> &extra);
@@ -128,6 +140,8 @@ private:
     unsigned mStreamType;
     unsigned mPCR_PID;
     int32_t mExpectedContinuityCounter;
+    uint64_t firstsPTS;
+    uint64_t lastsPTS;
 
     sp<ABuffer> mBuffer;
     sp<AnotherPacketSource> mSource;
@@ -135,8 +149,8 @@ private:
 
     ElementaryStreamQueue *mQueue;
 
-    status_t flush();
-    status_t parsePES(ABitReader *br);
+    status_t flush(bool onlypts = false);
+    status_t parsePES(ABitReader *br, bool onlypts = false);
 
     void onPayloadData(
             unsigned PTS_DTS_flags, uint64_t PTS, uint64_t DTS,
@@ -201,11 +215,13 @@ bool ATSParser::Program::parsePSISection(
 bool ATSParser::Program::parsePID(
         unsigned pid, unsigned continuity_counter,
         unsigned payload_unit_start_indicator,
-        ABitReader *br, status_t *err) {
+        ABitReader *br, status_t *err, bool onlypts) {
     *err = OK;
 
     ssize_t index = mStreams.indexOfKey(pid);
     if (index < 0) {
+        if (onlypts)
+           *err = ERROR_MALFORMED;
         return false;
     } else if (mTransition && (mNextVidPid == pid)) {
           sp<AMessage> extra;
@@ -217,9 +233,12 @@ bool ATSParser::Program::parsePID(
           mStreams.editValueAt(index)->setPID(mNextVidPid);
           mTransition = false;
     }
+    // If the control comes here and if check is for duration
+    // lock the PID as we need to find the PTS for same PID
+    // from end of file
 
     *err = mStreams.editValueAt(index)->parse(
-            continuity_counter, payload_unit_start_indicator, br);
+            continuity_counter, payload_unit_start_indicator, br, onlypts);
 
     return true;
 }
@@ -542,7 +561,9 @@ ATSParser::Stream::Stream(
       mPCR_PID(PCR_PID),
       mExpectedContinuityCounter(-1),
       mPayloadStarted(false),
-      mQueue(NULL) {
+      mQueue(NULL),
+      firstsPTS(0),
+      lastsPTS(0) {
     switch (mStreamType) {
         case STREAMTYPE_H264:
             mQueue = new ElementaryStreamQueue(
@@ -570,6 +591,21 @@ ATSParser::Stream::Stream(
                     ElementaryStreamQueue::MPEG4_VIDEO);
             break;
 
+        case STREAMTYPE_AUDIO_AC3:
+        case STREAMTYPE_AUDIO_EAC3:
+            mQueue = new ElementaryStreamQueue(
+                    ElementaryStreamQueue::AC3_AUDIO);
+            break;
+
+        case STREAMTYPE_AUDIO_LPCM:
+            mQueue = new ElementaryStreamQueue(
+                    ElementaryStreamQueue::LPCM_AUDIO);
+            break;
+        case STREAMTYPE_VC1_VIDEO:
+            mQueue = new ElementaryStreamQueue(
+                    ElementaryStreamQueue::VC1_VIDEO);
+            break;
+
         default:
             break;
     }
@@ -589,9 +625,43 @@ ATSParser::Stream::~Stream() {
 
 status_t ATSParser::Stream::parse(
         unsigned continuity_counter,
-        unsigned payload_unit_start_indicator, ABitReader *br) {
+        unsigned payload_unit_start_indicator, ABitReader *br, bool onlypts) {
     if (mQueue == NULL) {
-        return OK;
+        if (!onlypts) {
+            return OK;
+        } else {
+            ALOGV("mQueue is NULL, probably unsupported track in stream");
+            return ERROR_MALFORMED;
+        }
+    }
+
+    // Accumulate the buffer for finding PTS first
+    if (onlypts) {
+        size_t payloadSizeBits = br->numBitsLeft();
+        CHECK_EQ(payloadSizeBits % 8, 0u);
+
+        size_t neededSize = mBuffer->size() + payloadSizeBits / 8;
+        if (mBuffer->capacity() < neededSize) {
+            // Increment in multiples of 64K.
+            neededSize = (neededSize + 65535) & ~65535;
+            ALOGI("resizing buffer to %d bytes", neededSize);
+            sp<ABuffer> newBuffer = new ABuffer(neededSize);
+            memcpy(newBuffer->data(), mBuffer->data(), mBuffer->size());
+            newBuffer->setRange(0, mBuffer->size());
+            mBuffer = newBuffer;
+        }
+
+        memcpy(mBuffer->data() + mBuffer->size(), br->data(), payloadSizeBits / 8);
+        mBuffer->setRange(0, mBuffer->size() + payloadSizeBits / 8);
+
+        if (payload_unit_start_indicator) {
+            status_t err = flush(onlypts);
+            return err;
+        } else {
+            // discard the buffer as it may screw during reverse read
+            mBuffer->setRange(0,0);
+            return ERROR_MALFORMED;
+        }
     }
 
     if (mExpectedContinuityCounter >= 0
@@ -655,6 +725,7 @@ bool ATSParser::Stream::isVideo() const {
         case STREAMTYPE_MPEG1_VIDEO:
         case STREAMTYPE_MPEG2_VIDEO:
         case STREAMTYPE_MPEG4_VIDEO:
+        case STREAMTYPE_VC1_VIDEO:
             return true;
 
         default:
@@ -667,6 +738,9 @@ bool ATSParser::Stream::isAudio() const {
         case STREAMTYPE_MPEG1_AUDIO:
         case STREAMTYPE_MPEG2_AUDIO:
         case STREAMTYPE_MPEG2_AUDIO_ADTS:
+        case STREAMTYPE_AUDIO_AC3:
+        case STREAMTYPE_AUDIO_EAC3:
+        case STREAMTYPE_AUDIO_LPCM:
             return true;
 
         default:
@@ -722,7 +796,7 @@ void ATSParser::Stream::signalEOS(status_t finalResult) {
     }
 }
 
-status_t ATSParser::Stream::parsePES(ABitReader *br) {
+status_t ATSParser::Stream::parsePES(ABitReader *br, bool onlypts) {
     unsigned packet_startcode_prefix = br->getBits(24);
 
     ALOGV("packet_startcode_prefix = 0x%08x", packet_startcode_prefix);
@@ -796,6 +870,23 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
             CHECK_EQ(br->getBits(1), 1u);
 
             ALOGV("PTS = 0x%016llx (%.2f)", PTS, PTS / 90000.0);
+            if (onlypts) {
+                if (PTS > 0 && firstsPTS == 0) {
+                    firstsPTS = PTS;
+                    mProgram->setFirstPts(PTS);
+                    mProgram->setDurationPID(pid());
+                    ALOGV("firstPTS = %.2f secs for PID %d", PTS / 90000.0f, pid());
+                    return OK;
+                } else if (PTS > 0 && lastsPTS == 0) {
+                    lastsPTS = PTS;
+                    mProgram->setLastPts(PTS);
+                    ALOGV("lastPTS = %.2f secs for PID %d", PTS / 90000.0f, pid());
+                    return OK;
+                }
+                // if control comes here while checking duration,
+                // we should return error
+                return ERROR_MALFORMED;
+            }
 
             optional_bytes_remaining -= 5;
 
@@ -897,10 +988,13 @@ status_t ATSParser::Stream::parsePES(ABitReader *br) {
         br->skipBits(PES_packet_length * 8);
     }
 
+    if (onlypts)
+        return ERROR_MALFORMED;
+
     return OK;
 }
 
-status_t ATSParser::Stream::flush() {
+status_t ATSParser::Stream::flush(bool onlypts) {
     if (mBuffer->size() == 0) {
         return OK;
     }
@@ -913,11 +1007,13 @@ status_t ATSParser::Stream::flush() {
     // For dvb support check if the stream is actual PES or
     // some other DVB stream messages like DBB/DSM-CC
     if (ptr[0] == 0x00 && ptr[1] == 0x00 && ptr[2] == 0x01) {
-        err = parsePES(&br);
+        err = parsePES(&br, onlypts);
     }
     else {
         ALOGV("Skipping DVB specific messages now");
         br.skipBits(mBuffer->size() * 8);
+        if (onlypts)
+            err = ERROR_MALFORMED;
     }
 
     mBuffer->setRange(0, 0);
@@ -997,7 +1093,10 @@ ATSParser::ATSParser(uint32_t flags)
     : mFlags(flags),
       mAbsoluteTimeAnchorUs(-1ll),
       mNumTSPacketsParsed(0),
-      mNumPCRs(0) {
+      mNumPCRs(0),
+      firstPTS(0),
+      lastPTS(0),
+      mDurationPID(0)  {
     mPSISections.add(0 /* PID */, new PSISection);
 	tsPacketLen = kTSPacketSize;
 }
@@ -1013,10 +1112,24 @@ ssize_t ATSParser::GetTsPacketLength() {
     return tsPacketLen;
 }
 
+bool ATSParser::computePts(const void *data, size_t size) {
+    bool status = false;
+    ABitReader br((const uint8_t *)data, GetTsPacketLength());
+    br.skipBits(32);
+    if (parseTS(&br, true) == OK) {
+       status = true;
+    }
+    return status;
+}
+
+uint64_t ATSParser::computeDuration() {
+    return ((lastPTS - firstPTS) * 100/9);
+}
+
 status_t ATSParser::feedTSPacket(const void *data, size_t size) {
     CHECK_EQ(size, GetTsPacketLength());
 
-    ABitReader br((const uint8_t *)data, kTSPacketSize);
+    ABitReader br((const uint8_t *)data, GetTsPacketLength());
     if (GetTsPacketLength() == 192) {
         ALOGV("Blue Ray/M2TS content");
         br.skipBits(32);
@@ -1115,7 +1228,7 @@ void ATSParser::parseProgramAssociationTable(ABitReader *br) {
 status_t ATSParser::parsePID(
         ABitReader *br, unsigned PID,
         unsigned continuity_counter,
-        unsigned payload_unit_start_indicator) {
+        unsigned payload_unit_start_indicator, bool onlypts) {
     ssize_t sectionIndex = mPSISections.indexOfKey(PID);
 
     if (sectionIndex >= 0) {
@@ -1168,6 +1281,9 @@ status_t ATSParser::parsePID(
 
         section->clear();
 
+        if (onlypts)
+           return ERROR_MALFORMED;
+
         return OK;
     }
 
@@ -1176,7 +1292,7 @@ status_t ATSParser::parsePID(
         status_t err;
         if (mPrograms.editItemAt(i)->parsePID(
                     PID, continuity_counter, payload_unit_start_indicator,
-                    br, &err)) {
+                    br, &err, onlypts)) {
             if (err != OK) {
                 return err;
             }
@@ -1186,6 +1302,9 @@ status_t ATSParser::parsePID(
         }
     }
 
+    if (onlypts && !handled)
+       return ERROR_MALFORMED;
+
     if (!handled) {
         ALOGV("PID 0x%04x not handled.", PID);
     }
@@ -1220,7 +1339,7 @@ void ATSParser::parseAdaptationField(ABitReader *br, unsigned PID) {
             // MPEG2 transport stream packet up and including
             // the final byte of this PCR_ext field.
             size_t byteOffsetFromStartOfTSPacket =
-                (188 - br->numBitsLeft() / 8);
+                (GetTsPacketLength() - br->numBitsLeft() / 8);
 
             uint64_t PCR = PCR_base * 300 + PCR_ext;
 
@@ -1230,7 +1349,7 @@ void ATSParser::parseAdaptationField(ABitReader *br, unsigned PID) {
             // The number of bytes received by this parser up to and
             // including the final byte of this PCR_ext field.
             size_t byteOffsetFromStart =
-                mNumTSPacketsParsed * 188 + byteOffsetFromStartOfTSPacket;
+                mNumTSPacketsParsed * GetTsPacketLength() + byteOffsetFromStartOfTSPacket;
 
             for (size_t i = 0; i < mPrograms.size(); ++i) {
                 updatePCR(PID, PCR, byteOffsetFromStart);
@@ -1245,7 +1364,7 @@ void ATSParser::parseAdaptationField(ABitReader *br, unsigned PID) {
     }
 }
 
-status_t ATSParser::parseTS(ABitReader *br) {
+status_t ATSParser::parseTS(ABitReader *br, bool onlypts) {
     ALOGV("---");
 
     unsigned sync_byte = br->getBits(8);
@@ -1255,6 +1374,10 @@ status_t ATSParser::parseTS(ABitReader *br) {
     if (transport_error_indicator) {
         ALOGI("transport_error_indicator is set, ignoring packet");
         br->skipBits(br->numBitsLeft());
+
+        if (onlypts)
+           return ERROR_MALFORMED;
+
         return OK;
     }
 
@@ -1265,11 +1388,17 @@ status_t ATSParser::parseTS(ABitReader *br) {
 
     unsigned PID = br->getBits(13);
     ALOGV("PID = 0x%04x", PID);
-    if (PID == 0x1FFF) {
+    if ((PID == 0x1FFF) && (!onlypts)) {
         ALOGV("Found NULL Packet, Ignoring");
         return OK;
     }
 
+    if (onlypts && (mDurationPID != 0) && (mDurationPID != PID)) {
+        // We already have identified a PES with a PID to supply first PTS
+        // so ignore other PID's for duration
+        return ERROR_MALFORMED;
+    }
+
     MY_LOGV("transport_scrambling_control = %u", br->getBits(2));
 
     unsigned adaptation_field_control = br->getBits(2);
@@ -1288,11 +1417,14 @@ status_t ATSParser::parseTS(ABitReader *br) {
 
     if (adaptation_field_control == 1 || adaptation_field_control == 3) {
         err = parsePID(
-                br, PID, continuity_counter, payload_unit_start_indicator);
+                br, PID, continuity_counter, payload_unit_start_indicator, onlypts);
     }
 
     ++mNumTSPacketsParsed;
 
+    if ((adaptation_field_control == 2) && onlypts)
+        return ERROR_MALFORMED;
+
     return err;
 }
 
diff --git a/media/libstagefright/mpeg2ts/ATSParser.h b/media/libstagefright/mpeg2ts/ATSParser.h
index 69c564d..1cf80f1 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.h
+++ b/media/libstagefright/mpeg2ts/ATSParser.h
@@ -79,7 +79,17 @@ struct ATSParser : public RefBase {
 
     void SetTsPacketLength(ssize_t len);
 
-    ssize_t GetTsPacketLength();
+    ssize_t GetTsPacketLength(void);
+
+    bool computePts(const void* buf, size_t size);
+
+    uint64_t computeDuration(void);
+
+    void setFirstPts(uint64_t PTS) { firstPTS = PTS; }
+
+    void setLastPts(uint64_t PTS) { lastPTS = PTS; }
+
+    void setDurationPID (unsigned pid) { mDurationPID = pid; };
 
     enum {
         // From ISO/IEC 13818-1: 2000 (E), Table 2-29
@@ -90,7 +100,11 @@ struct ATSParser : public RefBase {
         STREAMTYPE_MPEG2_AUDIO          = 0x04,
         STREAMTYPE_MPEG2_AUDIO_ADTS     = 0x0f,
         STREAMTYPE_MPEG4_VIDEO          = 0x10,
+        STREAMTYPE_AUDIO_LPCM           = 0x80,
         STREAMTYPE_H264                 = 0x1b,
+        STREAMTYPE_AUDIO_AC3            = 0x81,
+        STREAMTYPE_AUDIO_EAC3           = 0x84, //BDAV specs
+        STREAMTYPE_VC1_VIDEO            = 0xEA, //Private
     };
 
 protected:
@@ -103,6 +117,9 @@ private:
     ssize_t tsPacketLen;
 
     uint32_t mFlags;
+    uint64_t firstPTS;
+    uint64_t lastPTS;
+    unsigned mDurationPID;
     Vector<sp<Program> > mPrograms;
 
     // Keyed by PID
@@ -119,10 +136,10 @@ private:
     status_t parsePID(
         ABitReader *br, unsigned PID,
         unsigned continuity_counter,
-        unsigned payload_unit_start_indicator);
+        unsigned payload_unit_start_indicator, bool onlypts = false);
 
     void parseAdaptationField(ABitReader *br, unsigned PID);
-    status_t parseTS(ABitReader *br);
+    status_t parseTS(ABitReader *br, bool onlypts = false);
 
     void updatePCR(unsigned PID, uint64_t PCR, size_t byteOffsetFromStart);
 
diff --git a/media/libstagefright/mpeg2ts/ESQueue.cpp b/media/libstagefright/mpeg2ts/ESQueue.cpp
index 1f8ba91..d351e13 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.cpp
+++ b/media/libstagefright/mpeg2ts/ESQueue.cpp
@@ -32,6 +32,54 @@
 #include "include/avc_utils.h"
 
 namespace android {
+static const struct {
+    const uint32_t bitrate;
+    const uint32_t framesize[3];
+}framesize_table[38] =
+{
+    { 32,    { 64, 69, 96}},
+    { 32,    { 64, 70, 96}},
+    { 40,    { 80, 87, 120}},
+    { 40,    { 80, 88, 120}},
+    { 48,    { 96, 104, 144}},
+    { 48,    { 96, 105, 144}},
+    { 56,    { 112, 121, 168}},
+    { 56,    { 112, 122, 168}},
+    { 64,    { 128, 139, 192}},
+    { 64,    { 128, 140, 192}},
+    { 80,    { 160, 174, 240}},
+    { 80,    { 160, 175, 240}},
+    { 96,    { 192, 208, 288}},
+    { 96,    { 192, 209, 288}},
+    { 112,   { 224, 243, 336}},
+    { 112,   { 224, 244, 336}},
+    { 128,   { 256, 278, 384}},
+    { 128,   { 256, 279, 384}},
+    { 160,   { 320, 348, 480}},
+    { 160,   { 320, 349, 480}},
+    { 192,   { 384, 417, 576}},
+    { 192,   { 384, 418, 576}},
+    { 224,   { 448, 487, 672}},
+    { 224,   { 448, 488, 672}},
+    { 256,   { 512, 557, 768}},
+    { 256,   { 512, 558, 768}},
+    { 320,   { 640, 696, 960}},
+    { 320,   { 640, 697, 960}},
+    { 384,   { 768, 835, 1152}},
+    { 384,   { 768, 836, 1152}},
+    { 448,   { 896, 975, 1344}},
+    { 448,   { 896, 976, 1344}},
+    { 512,   { 1024, 1114, 1536}},
+    { 512,   { 1024, 1115, 1536}},
+    { 576,   { 1152, 1253, 1728}},
+    { 576,   { 1152, 1254, 1728}},
+    { 640,   { 1280, 1393, 1920}},
+    { 640,   { 1280, 1394, 1920}}
+};
+
+static const uint32_t frame_rates[4] = { 48000, 44100, 32000, 0 };
+static const uint32_t acmod_channels[8] = { 2, 1, 2, 3, 3, 4, 4, 5 };
+static const uint32_t numblks[4] = { 1, 2, 3, 6 };
 
 ElementaryStreamQueue::ElementaryStreamQueue(Mode mode, uint32_t flags)
     : mMode(mode),
@@ -58,6 +106,40 @@ void ElementaryStreamQueue::clear(bool clearFormat) {
     }
 }
 
+static bool IsSeeminglyValidVC1SeqHeader(const uint8_t *ptr, size_t size, uint16_t &w, uint16_t& h) 
+{
+    if (size < 9)
+        return false;
+
+    //Check sequence start code
+    if ((ptr[0] == 0x00) && (ptr[1] == 0x00) && (ptr[2] == 0x01) && (ptr[3] == 0x0F))
+    {
+        ptr += 4;
+        ABitReader br(ptr, size -4);
+        // Check profile and level
+        uint8_t profile = br.getBits(2);
+        uint8_t level = br.getBits(3);
+        br.skipBits(11);
+        uint16_t max_coded_width = br.getBits(12);
+        uint16_t max_coded_height = br.getBits(12);
+        uint16_t width = max_coded_width * 2 + 2;
+        uint16_t height = max_coded_height * 2 + 2;
+        if ((w != width) ||
+           (h != height))
+        {
+            w = width;
+            h = height;
+        }
+        ALOGV("profile is %d, level is %d width x height is %d x %d", profile, level, width, height);
+        // As per BDAV spec, only Advanced profile level 2 and level 3 are valid
+        if ((profile == 3) && ((level == 2) || (level == 3))) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
 static bool IsSeeminglyValidMPEG2SeqHeader(const uint8_t *ptr, size_t size, uint16_t& width, uint16_t& height) {
 
     if (size < 7)
@@ -79,71 +161,295 @@ static bool IsSeeminglyValidMPEG2SeqHeader(const uint8_t *ptr, size_t size, uint
     return false;
 }
 
-static bool IsSeeminglyValidADTSHeader(const uint8_t *ptr, size_t size) {
-    if (size < 3) {
-        // Not enough data to verify header.
+static bool ParseLPCMHeader(const uint8_t* data, size_t size, uint32_t* bps,
+                          uint32_t* rate, uint32_t* ch) {
+    ABitReader br(data, size);
+    uint32_t hdr = br.getBits(32);
+    switch(( hdr & 0xf000) >> 12)
+    {
+    case 1:
+        *ch = 1;
+        break;
+    case 3:
+        *ch = 2;
+        break;
+    case 4:
+        *ch = 3;
+        break;
+    case 5:
+        *ch = 3;
+        break;
+    case 6:
+        *ch = 4;
+        break;
+    case 7:
+        *ch = 4;
+        break;
+    case 8:
+        *ch = 5;
+        break;
+    case 9:
+        *ch = 6;
+        break;
+    case 10:
+        *ch = 7;
+        break;
+    case 11:
+        *ch = 8;
+        break;
+
+    default:
         return false;
     }
 
-    if (ptr[0] != 0xff || (ptr[1] >> 4) != 0x0f) {
+    switch((hdr >> 6) & 0x03)
+    {
+    case 1:
+        *bps = 16;
+        break;
+    case 2: /* 20 bits but samples are stored on 24 bits */
+    case 3: /* 24 bits */
+        *bps = 24;
+        break;
+    default:
         return false;
     }
 
-    unsigned layer = (ptr[1] >> 1) & 3;
-
-    if (layer != 0) {
+    switch((hdr >> 8) & 0x0f)
+    {
+    case 1:
+        *rate = 48000;
+        break;
+    case 4:
+        *rate = 96000;
+        break;
+    case 5:
+        *rate = 192000;
+        break;
+    default:
         return false;
     }
 
-    unsigned ID = (ptr[1] >> 3) & 1;
-    unsigned profile_ObjectType = ptr[2] >> 6;
+    ALOGV("LPCM: Channnel count is %d, Sample Rate is %d, BPS is %d", *ch, *rate, *bps);
+    return true;
+}
 
-    if (ID == 1 && profile_ObjectType == 3) {
-        // MPEG-2 profile 3 is reserved.
+static bool ParseAC3Frame(const uint8_t* data, size_t size, uint32_t* framesize,
+                          uint32_t* rate, uint32_t* ch, uint32_t* blk,
+                          uint32_t* sid) {
+    ABitReader br(data, size);
+    uint8_t lfe_on = 0;
+    uint8_t acmod = 0;
+    br.skipBits(32);
+    uint8_t framescode = br.getBits(2);
+    uint8_t framesizecode = br.getBits(6);
+
+    if (framescode == 3 || framesizecode >= 38)
+        return false;
+
+    uint8_t bsid = br.getBits(5);
+    br.skipBits(3); //bsmod
+    acmod = br.getBits(3);
+
+    if (bsid > 8) {
+        ALOGV("Unexpected bsid");
+        return false;
+    } else if (bsid != 8 && bsid != 6)
+        // Spec not clear
+        ALOGV("Undefined bѕid, ignoring");
+
+    if ((acmod & 0x01) && (acmod != 0x01))
+        ALOGV("3 Front Channelѕ");
+    if ((acmod & 0x04))
+        ALOGV("Surround Channelѕ");
+    if ((acmod == 0x02))
+        ALOGV("Stereo Channelѕ");
+
+    br.skipBits(2);
+
+    lfe_on = br.getBits(1);
+
+    ALOGV("AC3 Frame Params framesize is \t\t %d \n sample rate is \t\t %d \n"  \
+         "number of channels \t\t %d \n num blocks \t\t %d \n sid \t\t %d",
+         framesize_table[framesizecode].framesize[framescode] *2 , frame_rates[framescode],
+         acmod_channels[acmod] + lfe_on, 6, 0);
+
+    if(framesize)
+        *framesize = framesize_table[framesizecode].framesize[framescode] * 2;
+
+    if(rate)
+        *rate = frame_rates[framescode];
+
+    if(ch)
+        *ch = acmod_channels[acmod] + lfe_on;
+
+    if(blk)
+        *blk = 6;
+
+    if(sid)
+       *sid = 0;
+
+    return true;
+
+}
+
+static bool ParseEAC3Frame(const uint8_t* data, size_t size, uint32_t* framesize,
+                          uint32_t* rate, uint32_t* ch, uint32_t* blk,
+                          uint32_t* sid) {
+    ABitReader br(data, size);
+    uint8_t lfe_on = 0;
+    uint8_t acmod = 0;
+    uint8_t framescode2 = 0;
+    uint8_t samplerate = 0;
+    uint8_t lblk = 0;
+    uint8_t numblkcode = 0;
+
+    ALOGV("Parsing EAC3");
+
+    br.skipBits(16);
+    uint8_t strmtype = br.getBits(2);
+
+    if (strmtype == 3) {
+        ALOGV("Bad Streamtype in EAC3");
         return false;
     }
 
-    // Check the aac_frame_length also as some ts packets have no valid aac frames
-    unsigned aac_frame_length = (((uint16_t)(ptr[3] & 0x3)) << 11)
-            | (((uint16_t)ptr[4]) << 3) | (ptr[5] >> 5);
-    if (aac_frame_length == 0)
+    uint8_t streamId = br.getBits(3);
+    uint8_t lframesize = br.getBits(11);
+    uint8_t framescode = br.getBits(2);
+    if (framescode == 3) {
+        framescode2 = br.getBits(2);
+        if (framescode2 == 3) {
+            ALOGV("Invalid framescode2 ");
+            return false;
+        }
+        samplerate = frame_rates[framescode2] / 2;
+        lblk = 6;
+    } else {
+        numblkcode = br.getBits(2);
+        samplerate = frame_rates[framescode];
+        lblk = numblks[numblkcode];
+    }
+
+    acmod = br.getBits(3);
+    lfe_on = br.getBits(1);
+
+    br.skipBits(5); //bsid
+
+    ALOGV("EAC3 Frame Params framesize is \t\t %d \n sample rate is \t\t %d \n" \
+         "number of channels \t\t %d \n num blocks \t\t %d \n sid \t\t %d",
+         (lframesize + 1) * 2 , samplerate,
+         acmod_channels[acmod] + lfe_on, lblk, (strmtype & 0x01) << 3 | streamId);
+
+    if(framesize)
+        *framesize = (lframesize + 1) * 2;
+
+    if(rate)
+        *rate = samplerate;
+
+    if(ch)
+        *ch = acmod_channels[acmod] + lfe_on;
+
+    if(blk)
+        *blk = lblk;
+
+    if(sid)
+       *sid = (strmtype & 0x01) << 3 | streamId;
+
+    return true;
+}
+
+static bool IsSeeminglyValidAC3Header(const uint8_t *ptr, size_t size,
+                      uint32_t* framesize, uint32_t* rate, uint32_t* ch,
+                      uint32_t* blk, uint32_t* sid, bool& iseac3) {
+    if (size < 6)
+        return false;
+
+    iseac3 = false;
+
+    ABitReader bits(ptr, size);
+    uint16_t sync = bits.getBits(16);
+    if(sync != 0x0b77)
        return false;
 
+    bits.skipBits(24);
+    uint8_t bsid = bits.getBits(5);
+    ALOGV(" AC3 bsid is %d", bsid);
+    if (bsid <= 10)
+    {
+        //parse ac3 frame header
+        if(!ParseAC3Frame(ptr, size, framesize, rate, ch, blk, sid))
+            return false;
+    }
+    else if (bsid <= 16)
+    {
+        iseac3 = true;
+        //parse the eac3 frame header
+        if(!ParseEAC3Frame(ptr, size, framesize, rate, ch, blk, sid))
+            return false;
+    }
     return true;
 }
 
-static bool IsSeeminglyValidMPEGAudioHeader(const uint8_t *ptr, size_t size) {
+static bool IsSeeminglyValidADTSHeader(const uint8_t *ptr, size_t size) {
     if (size < 3) {
         // Not enough data to verify header.
         return false;
     }
 
-    if (ptr[0] != 0xff || (ptr[1] >> 5) != 0x07) {
+    if (ptr[0] != 0xff || (ptr[1] >> 4) != 0x0f) {
         return false;
     }
 
-    unsigned ID = (ptr[1] >> 3) & 3;
-
-    if (ID == 1) {
-        return false;  // reserved
-    }
-
     unsigned layer = (ptr[1] >> 1) & 3;
 
-    if (layer == 0) {
-        return false;  // reserved
+    if (layer != 0) {
+        return false;
     }
 
-    unsigned bitrateIndex = (ptr[2] >> 4);
+    unsigned ID = (ptr[1] >> 3) & 1;
+    unsigned profile_ObjectType = ptr[2] >> 6;
 
-    if (bitrateIndex == 0x0f) {
-        return false;  // reserved
+    if (ID == 1 && profile_ObjectType == 3) {
+        // MPEG-2 profile 3 is reserved.
+        return false;
     }
 
-    unsigned samplingRateIndex = (ptr[2] >> 2) & 3;
+    // Check the aac_frame_length also as some ts packets have no valid aac frames
+    unsigned aac_frame_length = (((uint16_t)(ptr[3] & 0x3)) << 11)
+            | (((uint16_t)ptr[4]) << 3) | (ptr[5] >> 5);
+    if (aac_frame_length == 0)
+       return false;
 
-    if (samplingRateIndex == 3) {
-        return false;  // reserved
+    return true;
+}
+
+static bool IsSeeminglyValidMPEGAudioHeader(const uint8_t *ptr, size_t size) {
+    size_t frameSize = 0;
+    int    samplerate = 0;
+    int    channels = 0;
+    int    bitrate = 0;
+    int    num_out_samples = 0;
+    size_t offset = 0;
+    uint8_t success = 0;
+
+    while (offset < (size - 4)) {
+        uint32_t header = U32_AT(ptr + offset);
+        bool ret = GetMPEGAudioFrameSize(header,
+                                   &frameSize,
+                                   &samplerate,
+                                   &channels,
+                                   &bitrate,
+                                   &num_out_samples);
+        if (!ret) {
+            //hexdump(&header, 4); // keeping it, intentional
+            ALOGV("Incorrect mp3 sync, resyncing");
+            return false;
+        }
+        offset += frameSize;
+        success++;
+        if (success == 3) // 3 back to back frames is enough to trust
+           break;
     }
 
     return true;
@@ -292,6 +598,73 @@ status_t ElementaryStreamQueue::appendData(
                 break;
             }
 
+            case AC3_AUDIO:
+            {
+                uint8_t *ptr = (uint8_t *)data;
+                ALOGV("Parsing AC3 audio stream");
+                ssize_t startOffset = -1;
+                bool iseac3 = false;
+                for (size_t i = 0; i < size; ++i) {
+                    if (IsSeeminglyValidAC3Header(&ptr[i], size - i, NULL,
+                                         NULL, NULL, NULL, NULL, iseac3)) {
+                        startOffset = i;
+                        break;
+                    }
+                }
+
+                if (startOffset < 0) {
+                    return ERROR_MALFORMED;
+                }
+
+                if (startOffset > 0) {
+                    ALOGI("found something resembling an AC3 syncword at offset %ld",
+                         startOffset);
+                }
+                data = &ptr[startOffset];
+                size -= startOffset;
+                break;
+            }
+
+            case LPCM_AUDIO:
+            {
+                uint8_t *ptr = (uint8_t *)data;
+                ALOGV("Parsing LPCM audio stream");
+                ssize_t startOffset = -1;
+                for (size_t i = 0; i < size; ++i) {
+                    uint32_t bps;
+                    uint32_t rate;
+                    uint32_t ch;
+                    if (ParseLPCMHeader(&ptr[i], size - i, &bps, &rate, &ch)) {
+                        startOffset = i;
+                        break;
+                    }
+                }
+
+                if (startOffset < 0) {
+                    return ERROR_MALFORMED;
+                }
+
+                if (startOffset > 0) {
+                    ALOGI("found something resembling an LPCM syncword at offset %ld",
+                         startOffset);
+                }
+                data = &ptr[startOffset];
+                size -= startOffset;
+                break;
+            }
+
+            case VC1_VIDEO:
+            {
+                uint8_t *ptr = (uint8_t *)data;
+                // Make sure we always start with a sequence header IDU
+                if ((IsSeeminglyValidVC1SeqHeader(&ptr[0], size, mvideoWidth, mvideoHeight)))
+                    bseqHdrSent = true;
+                else if (!bseqHdrSent)
+                    return ERROR_MALFORMED;
+
+                break;
+            }
+
             default:
                 TRESPASS();
                 break;
@@ -368,12 +741,140 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnit() {
             return dequeueAccessUnitMPEGVideo();
         case MPEG4_VIDEO:
             return dequeueAccessUnitMPEG4Video();
+        case AC3_AUDIO:
+            return dequeueAccessUnitAC3();
+        case LPCM_AUDIO:
+            return dequeueAccessUnitLPCM();
+        case VC1_VIDEO:
+            return dequeueAccessUnitVC1Video();
         default:
             CHECK_EQ((unsigned)mMode, (unsigned)MPEG_AUDIO);
             return dequeueAccessUnitMPEGAudio();
     }
 }
 
+sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitVC1Video() {
+    size_t auSize = mBuffer->size();
+    uint8_t *data = mBuffer->data();
+
+    if(auSize == 0)
+        return NULL;
+
+     if (mFormat == NULL) {
+        //Create codec spefic data
+        mFormat = new MetaData;
+        mFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_WMV);
+        ALOGE("Setting Mimetype as MEDIA_MIMETYPE_VIDEO_WMV");
+        ALOGE("Width is %d, Height is %d", mvideoWidth, mvideoHeight);
+        mFormat->setInt32(kKeyWidth, mvideoWidth);
+        mFormat->setInt32(kKeyHeight, mvideoHeight);
+    }
+
+    int64_t timeUs = fetchTimestamp(auSize);
+    sp<ABuffer> accessUnit = new ABuffer(auSize);
+    memcpy(accessUnit->data(), mBuffer->data(), auSize);
+    mBuffer->setRange(0, mBuffer->size() - auSize);
+
+    if (timeUs >= 0) {
+       accessUnit->meta()->setInt64("timeUs", timeUs);
+    } else {
+       ALOGW("no time for VC1 access unit");
+    }
+
+    return accessUnit;
+}
+
+sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitLPCM() {
+    size_t auSize = mBuffer->size();
+    uint32_t sample_rate = 0;
+    uint32_t channels = 0;
+    uint32_t bps = 0;
+
+    if(auSize == 0)
+        return NULL;
+
+     if (mFormat == NULL) {
+         //Create codec spefic data
+        if (!ParseLPCMHeader(mBuffer->data(), mBuffer->size(),
+                                   &bps, &sample_rate, &channels)) {
+             //Discard this buffer and proceed
+            ALOGV("Failed to parse the LPCM header");
+            return NULL;
+        }
+        mFormat = new MetaData;
+        mFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+        ALOGE("Setting Mimetype as MEDIA_MIME_TYPE_AUDIO_RAW");
+        ALOGE("Setting SampleRate as %d and channels as %d", sample_rate, channels);
+        mFormat->setInt32(kKeySampleRate, sample_rate);
+        mFormat->setInt32(kKeyChannelCount, channels);
+    }
+
+    int64_t timeUs = fetchTimestamp(auSize);
+    sp<ABuffer> accessUnitSwapped = new ABuffer(auSize - 4);
+    // Swap and copy data, ignore first 4 byte header
+    uint8_t* data = mBuffer->data() + 4;
+    uint8_t tmp;
+    for (int index = 0; index < (auSize - 4); index += 2) {
+       tmp = data[index];
+       data[index] = data[index + 1];
+       data[index + 1] = tmp;
+    }
+
+    memcpy(accessUnitSwapped->data(), mBuffer->data() + 4, auSize - 4);
+    mBuffer->setRange(0, mBuffer->size() - auSize);
+
+    if (timeUs >= 0) {
+       accessUnitSwapped->meta()->setInt64("timeUs", timeUs);
+    } else {
+       ALOGW("no time for LPCM access unit");
+    }
+
+    return accessUnitSwapped;
+}
+
+sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitAC3() {
+    size_t auSize = mBuffer->size();
+    uint32_t framesize = 0;
+    uint32_t sample_rate = 0;
+    uint32_t channels = 0;
+    uint32_t numBlks = 0;
+    uint32_t sid = 0;
+    bool iseac3 = false;
+
+    if (mFormat == NULL) {
+        //Create codec spefic data
+        if (!IsSeeminglyValidAC3Header(mBuffer->data(), mBuffer->size(),
+                                   &framesize, &sample_rate, &channels,
+                                   &numBlks, &sid, iseac3)) {
+            //Discard this buffer and proceed
+            ALOGV("Failed to parse the AC3 header");
+            return NULL;
+        }
+        mFormat = new MetaData;
+        mFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);
+        ALOGV("Setting Mimetype as MEDIA_MIME_TYPE_AUDIO_AC3");
+        mFormat->setInt32(kKeySampleRate, sample_rate);
+        mFormat->setInt32(kKeyChannelCount, channels);
+    }
+
+    if(auSize == 0)
+        return NULL;
+
+    int64_t timeUs = fetchTimestamp(auSize);
+    sp<ABuffer> accessUnit = new ABuffer(auSize);
+    memcpy(accessUnit->data(), mBuffer->data(), auSize);
+    memmove(mBuffer->data(), mBuffer->data() + auSize,
+            mBuffer->size() - auSize);
+    mBuffer->setRange(0, mBuffer->size() - auSize);
+
+    if (timeUs >= 0) {
+        accessUnit->meta()->setInt64("timeUs", timeUs);
+    } else {
+        ALOGW("no time for AC3 access unit");
+    }
+    return accessUnit;
+}
+
 sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitAAC() {
     int64_t timeUs;
 
@@ -531,7 +1032,11 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitH264() {
         unsigned nalType = nalStart[0] & 0x1f;
         bool flush = false;
 
-        if (nalType == 1 || nalType == 5) {
+        if (!bseqHdrSent && (nalType == 5  || nalType == 1)) {
+            bseqHdrSent = true;
+        }
+
+        if (bseqHdrSent && (nalType == 1 || nalType == 5)) {
             if (foundSlice) {
                 ABitReader br(nalStart + 1, nalSize);
                 unsigned first_mb_in_slice = parseUE(&br);
@@ -645,9 +1150,15 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitMPEGAudio() {
 
     size_t frameSize;
     int samplingRate, numChannels, bitrate, numSamples;
-    CHECK(GetMPEGAudioFrameSize(
+
+    if (!GetMPEGAudioFrameSize(
                 header, &frameSize, &samplingRate, &numChannels,
-                &bitrate, &numSamples));
+                &bitrate, &numSamples)) {
+       // ignore the complete buffer and force resync
+       ALOGE("Lost MPEG Audio sync");
+       mBuffer->setRange(0,0);
+       return NULL;
+    }
 
     if (size < frameSize) {
         return NULL;
diff --git a/media/libstagefright/mpeg2ts/ESQueue.h b/media/libstagefright/mpeg2ts/ESQueue.h
index 4e24254..97fd855 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.h
+++ b/media/libstagefright/mpeg2ts/ESQueue.h
@@ -35,6 +35,9 @@ struct ElementaryStreamQueue {
         MPEG_AUDIO,
         MPEG_VIDEO,
         MPEG4_VIDEO,
+        AC3_AUDIO,
+        LPCM_AUDIO,
+        VC1_VIDEO,
     };
 
     enum Flags {
@@ -72,6 +75,9 @@ private:
     sp<ABuffer> dequeueAccessUnitMPEGAudio();
     sp<ABuffer> dequeueAccessUnitMPEGVideo();
     sp<ABuffer> dequeueAccessUnitMPEG4Video();
+    sp<ABuffer> dequeueAccessUnitAC3();
+    sp<ABuffer> dequeueAccessUnitLPCM();
+    sp<ABuffer> dequeueAccessUnitVC1Video();
 
     // consume a logical (compressed) access unit of size "size",
     // returns its timestamp in us (or -1 if no time information).
diff --git a/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp b/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp
index ee3dd70..cd4c3f0 100644
--- a/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp
+++ b/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp
@@ -28,6 +28,7 @@
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MetaData.h>
+#include <media/IStreamSource.h>
 #include <utils/String8.h>
 
 #include "AnotherPacketSource.h"
@@ -88,6 +89,10 @@ sp<MetaData> MPEG2TSSource::getFormat() {
         meta->setInt64(kKeyDuration, durationUs);
     }
 
+    if (mExtractor->IsM2TSMedia()) {
+       meta->setInt64(kKeyDuration, mExtractor->GetM2TSDuration());
+    }
+
     return meta;
 }
 
@@ -95,9 +100,14 @@ status_t MPEG2TSSource::read(
         MediaBuffer **out, const ReadOptions *options) {
     *out = NULL;
 
-    int64_t seekTimeUs;
+    int64_t seekTimeUs = 0;
     ReadOptions::SeekMode seekMode;
-    if (mSeekable && options && options->getSeekTo(&seekTimeUs, &seekMode)) {
+    if (options && options->getSeekTo(&seekTimeUs, &seekMode) && (seekTimeUs == 0)) {
+       // reset the position for thumbnail case
+       mExtractor->mOffset = 0;
+    }
+
+    if (mSeekable && seekTimeUs > 0) {
         mExtractor->seekTo(seekTimeUs);
     }
 
@@ -121,7 +131,10 @@ status_t MPEG2TSSource::read(
 MPEG2TSExtractor::MPEG2TSExtractor(const sp<DataSource> &source)
     : mDataSource(source),
       mParser(new ATSParser),
-      mOffset(0) {
+      mOffset(0),
+      durationUs(-1),
+      fileSize(0),
+      isM2TSMedia(false) {
     init();
 }
 
@@ -141,8 +154,8 @@ sp<MediaSource> MPEG2TSExtractor::getTrack(size_t index) {
         sp<MetaData> meta = mSourceImpls.editItemAt(index)->getFormat();
         const char *mime;
         CHECK(meta->findCString(kKeyMIMEType, &mime));
-
-        if (!strncasecmp("audio/", mime, 6)) {
+        if ((!isM2TSMedia) ||
+            (!strncasecmp("audio/", mime, 6))) {
             seekable = false;
         }
     }
@@ -152,6 +165,31 @@ sp<MediaSource> MPEG2TSExtractor::getTrack(size_t index) {
 
 sp<MetaData> MPEG2TSExtractor::getTrackMetaData(
         size_t index, uint32_t flags) {
+    if (isM2TSMedia) {
+        sp<MetaData> meta;
+        if (index < mSourceImpls.size()) {
+            meta = mSourceImpls.editItemAt(index)->getFormat();
+        }
+        // For LPCM Audio
+        const char *mime;
+        CHECK(meta->findCString(kKeyMIMEType, &mime));
+        if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_RAW, mime)) {
+            ALOGE("RAW Audio Type, Setting track duration as %lld", durationUs);
+            meta->setInt64(kKeyDuration, durationUs);
+        }
+
+        if (flags & kIncludeExtensiveMetaData) {
+            const char *mime;
+            CHECK(meta->findCString(kKeyMIMEType, &mime));
+            if (!strncasecmp("video/", mime, 6)) {
+                if (durationUs > (7 * 1000000)) {
+                    meta->setInt64( kKeyThumbnailTime, (7 * 1000000));
+                }
+            }
+        }
+        return meta;
+    }
+
     return index < mSourceImpls.size()
         ? mSourceImpls.editItemAt(index)->getFormat() : NULL;
 }
@@ -183,11 +221,16 @@ void MPEG2TSExtractor::init() {
              else if (*(header + 4) == 0x47)
              {
                  mParser->SetTsPacketLength(kMaxTSPacketSize);
+                 isM2TSMedia = true;
              }
         }
         ALOGV("Set the TS packet size as %d", mParser->GetTsPacketLength());
     }
 
+    if (isM2TSMedia) {
+        ALOGE("Duration of m2ts media is %lld", GetM2TSDuration());
+    }
+
     while (feedMore() == OK) {
         ATSParser::SourceType type;
         if (haveAudio && haveVideo) {
@@ -247,6 +290,21 @@ void MPEG2TSExtractor::setLiveSession(const sp<LiveSession> &liveSession) {
 
 void MPEG2TSExtractor::seekTo(int64_t seekTimeUs) {
     Mutex::Autolock autoLock(mLock);
+    // M2TS seek
+    if ((isM2TSMedia) && (mLiveSession == NULL)) {
+         sp<AMessage> extra = new AMessage;
+         extra->setInt64(IStreamListener::kKeyResumeAtPTS, (seekTimeUs/100) * 9);
+         mParser->signalDiscontinuity(ATSParser::DISCONTINUITY_TIME, extra);
+         // Now convert seekTo point to fileoffset and set mOffset to there
+         ALOGV("In SeekTo fileSize: %lld seekTimeUs : %lld durationUs: %lld", fileSize, seekTimeUs, durationUs);
+         off64_t seekOffset = (fileSize / (1.0 * durationUs)) * seekTimeUs;
+         // Align the offset to 192
+         ALOGV("Seek offset is %lld", seekOffset);
+         seekOffset -= (seekOffset % mParser->GetTsPacketLength());
+         ALOGV("Aligned Seek offset is %lld", seekOffset);
+         mOffset = seekOffset;
+         return;
+    }
 
     if (mLiveSession == NULL) {
         return;
@@ -260,13 +318,77 @@ uint32_t MPEG2TSExtractor::flags() const {
 
     uint32_t flags = CAN_PAUSE;
 
-    if (mLiveSession != NULL && mLiveSession->isSeekable()) {
+    if (((isM2TSMedia) && (mLiveSession == NULL)) ||
+       (mLiveSession != NULL && mLiveSession->isSeekable())) {
         flags |= CAN_SEEK_FORWARD | CAN_SEEK_BACKWARD | CAN_SEEK;
     }
 
     return flags;
 }
 
+uint64_t MPEG2TSExtractor::GetM2TSDuration() {
+    bool firstPesFound = false;
+    bool lastPesFound  = false;
+    int64_t offset = 0;
+    unsigned residue = 0;
+    bool invalidmedia = false;
+
+    if (durationUs >= 0)
+        return durationUs;
+
+    if ((isM2TSMedia)&& (durationUs < 0)) {
+        // M2TS/MTS format, compute duration
+        uint8_t packet[kMaxTSPacketSize];
+        // Try hitting the first PES packet first
+        while (!firstPesFound) {
+            ssize_t n = mDataSource->readAt(offset, packet, mParser->GetTsPacketLength());
+
+            if (n < mParser->GetTsPacketLength()) {
+                // Invalid packets in file, set duration as 0
+                invalidmedia = true;
+                break;
+            }
+
+            offset += n;
+            firstPesFound = mParser->computePts(packet, mParser->GetTsPacketLength());
+        }
+        // Go backwards from end for last PES PTS
+        if (mDataSource->getSize(&fileSize) == OK) {
+            ALOGV("M2TS file size is %lld bytes", fileSize);
+            // Some m2ts files have truncated last frame so correct the last offset
+            residue = fileSize % mParser->GetTsPacketLength();
+            ALOGV("Warning M2TS file size is not multiple of 192 %d bytes", residue);
+        }
+
+        offset = (fileSize - residue) - mParser->GetTsPacketLength();
+        fileSize -= residue;
+        while (!lastPesFound) {
+            ssize_t n = mDataSource->readAt(offset, packet, mParser->GetTsPacketLength());
+
+            if (n < mParser->GetTsPacketLength()) {
+                // Invalid packets in file, set duration as 0
+                invalidmedia = true;
+                break;
+            }
+
+            offset -= n;
+            lastPesFound = mParser->computePts(packet, mParser->GetTsPacketLength());
+        }
+
+        if (!invalidmedia && (firstPesFound && lastPesFound)) {
+            durationUs = mParser->computeDuration();
+            return durationUs;
+        } else {
+            return 0;
+        }
+    }
+    return 0;
+}
+
+bool MPEG2TSExtractor::IsM2TSMedia() {
+    return (isM2TSMedia);
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 
 bool SniffMPEG2TS(
-- 
1.7.1

