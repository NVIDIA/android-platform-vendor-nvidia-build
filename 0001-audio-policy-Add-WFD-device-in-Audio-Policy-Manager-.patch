From 6f57a4b2f841fc3237d55b593bf2751f9d084b09 Mon Sep 17 00:00:00 2001
From: Nikesh Oswal <noswal@nvidia.com>
Date: Fri, 15 Jun 2012 16:36:46 +0530
Subject: [PATCH] audio policy: Add WFD device in Audio Policy Manager Base

Bug: 987484
Change-Id: I48ff8abc7f3f19ac429baa80801668d1c907c73c
Reviewed-on: http://git-psac/r/266
Reviewed-by: Rohan Somvanshi <rsomvanshi@nvidia.com>
Tested-by: Rohan Somvanshi <rsomvanshi@nvidia.com>

audio policy: added ac3/dts format enum

the ac3/dts enum is added and will be activated if ac3/dts
passthrough capability is supported.

bug 998699

Change-Id: Ia659cf3c4276591db8cda7be08a337d09fdd2e6d

AudioPolicyManager: Add support for dual audio

dual audio is a usecase where DUAL_AUDIO stream is rendered through
WFD/HDMI if available (otherwise via the next priority device) and
any other android stream is routed through speaker/headset. To support
this new stream type and new strategy is defined when dual audio stream
gets hold of WFD/HDMI then no other stream will be routed through
WFD/HDMI as long as dual audio stream is active

Bug 1054990

Change-Id: I59e361115d51d8f82828a0d4fc6cb3ea0c489c0b
---
 audio/AudioPolicyManagerBase.cpp                 |   80 ++++++++++++++++++++-
 include/hardware_legacy/AudioPolicyManagerBase.h |   13 +++-
 include/hardware_legacy/AudioSystemLegacy.h      |   10 +++
 3 files changed, 97 insertions(+), 6 deletions(-)

diff --git a/audio/AudioPolicyManagerBase.cpp b/audio/AudioPolicyManagerBase.cpp
index 35dd219..05bb7db 100644
--- a/audio/AudioPolicyManagerBase.cpp
+++ b/audio/AudioPolicyManagerBase.cpp
@@ -485,8 +485,20 @@ AudioPolicyManagerBase::IOProfile *AudioPolicyManagerBase::getProfileForDirectOu
                                                                uint32_t samplingRate,
                                                                uint32_t format,
                                                                uint32_t channelMask,
-                                                               audio_output_flags_t flags)
+                                                               audio_output_flags_t flags
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+                                                               ,AudioSystem::stream_type stream
+#endif
+                                                               )
 {
+    if ((channelMask == AUDIO_CHANNEL_OUT_MONO || channelMask == AUDIO_CHANNEL_OUT_STEREO) &&
+            (format == AUDIO_FORMAT_PCM_16_BIT)
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+            && (stream != AUDIO_DUAL_AUDIO)
+#endif
+            )
+        return 0; /*no direct o/p if not a multichannel/ulp/dual audio stream*/
+
     for (size_t i = 0; i < mHwModules.size(); i++) {
         if (mHwModules[i]->mHandle == 0) {
             continue;
@@ -555,7 +567,12 @@ audio_io_handle_t AudioPolicyManagerBase::getOutput(AudioSystem::stream_type str
                                                    samplingRate,
                                                    format,
                                                    channelMask,
-                                                   (audio_output_flags_t)flags);
+                                                   (audio_output_flags_t)flags
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+                                                   ,stream
+#endif
+                                                   );
+
     if (profile != NULL) {
 
         ALOGV("getOutput() opening direct output device %x", device);
@@ -976,13 +993,19 @@ void AudioPolicyManagerBase::initStreamVolume(AudioSystem::stream_type stream,
     }
     mStreams[stream].mIndexMin = indexMin;
     mStreams[stream].mIndexMax = indexMax;
+
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+    if (AudioSystem::MUSIC == stream) {
+        mStreams[AudioSystem::DUAL_AUDIO].mIndexMin = indexMin;
+        mStreams[AudioSystem::DUAL_AUDIO].mIndexMax = indexMax;
+    }
+#endif
 }
 
 status_t AudioPolicyManagerBase::setStreamVolumeIndex(AudioSystem::stream_type stream,
                                                       int index,
                                                       audio_devices_t device)
 {
-
     if ((index < mStreams[stream].mIndexMin) || (index > mStreams[stream].mIndexMax)) {
         return BAD_VALUE;
     }
@@ -1003,6 +1026,11 @@ status_t AudioPolicyManagerBase::setStreamVolumeIndex(AudioSystem::stream_type s
     }
     mStreams[stream].mIndexCur.add(device, index);
 
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+    if (AudioSystem::MUSIC == stream)
+        mStreams[AudioSystem::DUAL_AUDIO].mIndexCur.add(device, index);
+#endif
+
     // compute and apply stream volume on all outputs according to connected device
     status_t status = NO_ERROR;
     for (size_t i = 0; i < mOutputs.size(); i++) {
@@ -1996,7 +2024,13 @@ audio_devices_t AudioPolicyManagerBase::getNewDevice(audio_io_handle_t output, b
         device = getDeviceForStrategy(STRATEGY_SONIFICATION, fromCache);
     } else if (outputDesc->isUsedByStrategy(STRATEGY_SONIFICATION_RESPECTFUL)) {
         device = getDeviceForStrategy(STRATEGY_SONIFICATION_RESPECTFUL, fromCache);
-    } else if (outputDesc->isUsedByStrategy(STRATEGY_MEDIA)) {
+    }
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+    else if (outputDesc->isUsedByStrategy(STRATEGY_DUAL_AUDIO)) {
+        device = getDeviceForStrategy(STRATEGY_DUAL_AUDIO, fromCache);
+    }
+#endif
+    else if (outputDesc->isUsedByStrategy(STRATEGY_MEDIA)) {
         device = getDeviceForStrategy(STRATEGY_MEDIA, fromCache);
     } else if (outputDesc->isUsedByStrategy(STRATEGY_DTMF)) {
         device = getDeviceForStrategy(STRATEGY_DTMF, fromCache);
@@ -2048,6 +2082,10 @@ AudioPolicyManagerBase::routing_strategy AudioPolicyManagerBase::getStrategy(
         return STRATEGY_MEDIA;
     case AudioSystem::ENFORCED_AUDIBLE:
         return STRATEGY_ENFORCED_AUDIBLE;
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+    case AudioSystem::DUAL_AUDIO:
+        return STRATEGY_DUAL_AUDIO;
+#endif
     }
 }
 
@@ -2062,6 +2100,21 @@ void AudioPolicyManagerBase::handleNotificationRoutingForStream(AudioSystem::str
     }
 }
 
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+bool AudioPolicyManagerBase::isDualAudioActive()
+{
+    AudioOutputDescriptor *outputDesc;
+
+    for (size_t i = 0; i < mOutputs.size(); i++) {
+        outputDesc = mOutputs.valueFor(mOutputs.keyAt(i));
+        if (outputDesc->isUsedByStrategy(STRATEGY_DUAL_AUDIO))
+           return true;
+    }
+
+    return false;
+}
+#endif
+
 audio_devices_t AudioPolicyManagerBase::getDeviceForStrategy(routing_strategy strategy,
                                                              bool fromCache)
 {
@@ -2679,6 +2732,13 @@ const AudioPolicyManagerBase::VolumeCurvePoint
         sSpeakerMediaVolumeCurve, // DEVICE_CATEGORY_SPEAKER
         sDefaultMediaVolumeCurve  // DEVICE_CATEGORY_EARPIECE
     },
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+    { // AUDIO_DUAL_AUDIO
+        sDefaultMediaVolumeCurve, // DEVICE_CATEGORY_HEADSET
+        sSpeakerMediaVolumeCurve, // DEVICE_CATEGORY_SPEAKER
+        sDefaultMediaVolumeCurve  // DEVICE_CATEGORY_EARPIECE
+    },
+#endif
 };
 
 void AudioPolicyManagerBase::initializeVolumeCurves()
@@ -2792,6 +2852,12 @@ status_t AudioPolicyManagerBase::checkAndSetVolume(int stream,
             mpClientInterface->setStreamVolume(AudioSystem::VOICE_CALL, volume, output, delayMs);
         }
         mpClientInterface->setStreamVolume((AudioSystem::stream_type)stream, volume, output, delayMs);
+
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+        if (AudioSystem::MUSIC == stream)
+            mpClientInterface->setStreamVolume(AudioSystem::DUAL_AUDIO, volume, output, delayMs);
+#endif
+
     }
 
     if (stream == AudioSystem::VOICE_CALL ||
@@ -3351,6 +3417,9 @@ const struct StringToEnum sDeviceNameToEnumTable[] = {
     STRING_TO_ENUM(AUDIO_DEVICE_OUT_USB_ACCESSORY),
     STRING_TO_ENUM(AUDIO_DEVICE_OUT_ALL_USB),
     STRING_TO_ENUM(AUDIO_DEVICE_OUT_REMOTE_SUBMIX),
+#ifdef FRAMEWORK_HAS_WIFI_DISPLAY_SUPPORT
+    STRING_TO_ENUM(AUDIO_DEVICE_OUT_WIFI_DISPLAY),
+#endif
     STRING_TO_ENUM(AUDIO_DEVICE_IN_BUILTIN_MIC),
     STRING_TO_ENUM(AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET),
     STRING_TO_ENUM(AUDIO_DEVICE_IN_WIRED_HEADSET),
@@ -3376,6 +3445,9 @@ const struct StringToEnum sFormatNameToEnumTable[] = {
     STRING_TO_ENUM(AUDIO_FORMAT_MP3),
     STRING_TO_ENUM(AUDIO_FORMAT_AAC),
     STRING_TO_ENUM(AUDIO_FORMAT_VORBIS),
+#ifdef FRAMEWORK_HAS_AC3_DTS_PASSTHROUGH_SUPPORT
+    STRING_TO_ENUM(AUDIO_FORMAT_IEC61937),
+#endif
 };
 
 const struct StringToEnum sOutChannelsNameToEnumTable[] = {
diff --git a/include/hardware_legacy/AudioPolicyManagerBase.h b/include/hardware_legacy/AudioPolicyManagerBase.h
index 451fe8a..6c51215 100644
--- a/include/hardware_legacy/AudioPolicyManagerBase.h
+++ b/include/hardware_legacy/AudioPolicyManagerBase.h
@@ -146,6 +146,9 @@ protected:
             STRATEGY_SONIFICATION_RESPECTFUL,
             STRATEGY_DTMF,
             STRATEGY_ENFORCED_AUDIBLE,
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+            STRATEGY_DUAL_AUDIO,
+#endif
             NUM_STRATEGIES
         };
 
@@ -480,7 +483,11 @@ protected:
                                                        uint32_t samplingRate,
                                                        uint32_t format,
                                                        uint32_t channelMask,
-                                                       audio_output_flags_t flags);
+                                                       audio_output_flags_t flags
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+                                                       ,AudioSystem::stream_type stream
+#endif
+                                                       );
         //
         // Audio policy configuration file parsing (audio_policy.conf)
         //
@@ -500,7 +507,9 @@ protected:
         void loadGlobalConfig(cnode *root);
         status_t loadAudioPolicyConfig(const char *path);
         void defaultAudioPolicyConfig(void);
-
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+        bool isDualAudioActive();
+#endif
 
         AudioPolicyClientInterface *mpClientInterface;  // audio policy client interface
         audio_io_handle_t mPrimaryOutput;              // primary output handle
diff --git a/include/hardware_legacy/AudioSystemLegacy.h b/include/hardware_legacy/AudioSystemLegacy.h
index 6296b8b..3000e9e 100644
--- a/include/hardware_legacy/AudioSystemLegacy.h
+++ b/include/hardware_legacy/AudioSystemLegacy.h
@@ -81,6 +81,9 @@ public:
         ENFORCED_AUDIBLE = 7, // Sounds that cannot be muted by user and must be routed to speaker
         DTMF             = 8,
         TTS              = 9,
+#ifdef FRAMEWORK_HAS_DUAL_AUDIO_SUPPORT
+        DUAL_AUDIO = 10,
+#endif
         NUM_STREAM_TYPES
     };
 
@@ -244,12 +247,19 @@ public:
         DEVICE_OUT_ANLG_DOCK_HEADSET = 0x800,
         DEVICE_OUT_DGTL_DOCK_HEADSET = 0x1000,
         DEVICE_OUT_DEFAULT = 0x8000,
+#ifdef FRAMEWORK_HAS_WIFI_DISPLAY_SUPPORT
+        DEVICE_OUT_WIFI_DISPLAY = 0x1000000,
+#endif
         DEVICE_OUT_ALL = (DEVICE_OUT_EARPIECE | DEVICE_OUT_SPEAKER | DEVICE_OUT_WIRED_HEADSET |
                 DEVICE_OUT_WIRED_HEADPHONE | DEVICE_OUT_BLUETOOTH_SCO | DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
                 DEVICE_OUT_BLUETOOTH_SCO_CARKIT | DEVICE_OUT_BLUETOOTH_A2DP | DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
                 DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER | DEVICE_OUT_AUX_DIGITAL |
                 DEVICE_OUT_ANLG_DOCK_HEADSET | DEVICE_OUT_DGTL_DOCK_HEADSET |
+#ifdef FRAMEWORK_HAS_WIFI_DISPLAY_SUPPORT
+                DEVICE_OUT_DEFAULT | DEVICE_OUT_WIFI_DISPLAY),
+#else
                 DEVICE_OUT_DEFAULT),
+#endif
         DEVICE_OUT_ALL_A2DP = (DEVICE_OUT_BLUETOOTH_A2DP | DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
                 DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER),
 
-- 
1.7.1

